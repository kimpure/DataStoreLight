return [======[{"sessionId":"474a8385-5a42-4d96-aa34-2d43fc917440","messageCursor":0,"instances":{"d539d2b3547c9166dae5ffd367a37cb3":{"Id":"d539d2b3547c9166dae5ffd367a37cb3","Parent":"e412d57eace8911b86fabef6e8521d77","Name":"Types","ClassName":"ModuleScript","Properties":{"Source":{"String":"local IContext: (obj: any) -> boolean = require(script.IContext)\nlocal ISubscription: (obj: any) -> boolean = require(script.ISubscription)\nlocal IWormhole: (obj: any) -> boolean = require(script.IWormhole)\nlocal ContextBlock: (obj: any) -> boolean = require(script.ContextBlock)\nlocal IPackage: (obj: any) -> boolean = require(script.IPackage)\n\nexport type IContext = IContext.IContext\nexport type ISubscription = ISubscription.ISubscription\nexport type IWormhole = IWormhole.IWormhole\nexport type ContextBlock = ContextBlock.ContextBlock\nexport type IPackage = IPackage.IPackage\n\nlocal Checks: { [string]: (obj: any) -> boolean } = {\n\t[\"isContext\"] = IContext,\n\t[\"isSubscription\"] = ISubscription,\n\t[\"isWormhole\"] = IWormhole,\n\t[\"isContextBlock\"] = ContextBlock,\n\t[\"isPackage\"] = IPackage,\n}\n\nreturn Checks\n"}},"Children":["133a9b005fbea6beac1d059ddc9fef0e","46bcc92ca5dc93da75ba685ae7cb4991","9c8522e307357cb958492ee98fd93042","6978a188358d64bfb2103712202a9922","c7c89a6fc94431da37e9bff85b81ab47"],"Metadata":{"ignoreUnknownInstances":false}},"6957f7983ac08acabf224266f365d3f7":{"Id":"6957f7983ac08acabf224266f365d3f7","Parent":"9cd69536a0dc973cffeed65b16a569e0","Name":"init.spec","ClassName":"ModuleScript","Properties":{"Source":{"String":"return function()\r\n\tlocal Promise = require(script.Parent)\r\n\tPromise.TEST = true\r\n\r\n\tlocal timeEvent = Instance.new(\"BindableEvent\")\r\n\tPromise._timeEvent = timeEvent.Event\r\n\r\n\tlocal advanceTime do\r\n\t\tlocal injectedPromiseTime = 0\r\n\r\n\t\tPromise._getTime = function()\r\n\t\t\treturn injectedPromiseTime\r\n\t\tend\r\n\r\n\t\tfunction advanceTime(delta)\r\n\t\t\tdelta = delta or (1/60)\r\n\r\n\t\t\tinjectedPromiseTime = injectedPromiseTime + delta\r\n\t\t\ttimeEvent:Fire(delta)\r\n\t\tend\r\n\tend\r\n\r\n\tlocal function pack(...)\r\n\t\tlocal len = select(\"#\", ...)\r\n\r\n\t\treturn len, { ... }\r\n\tend\r\n\r\n\tdescribe(\"Promise.Status\", function()\r\n\t\tit(\"should error if indexing nil value\", function()\r\n\t\t\texpect(function()\r\n\t\t\t\tlocal _ = Promise.Status.wrong\r\n\t\t\tend).to.throw()\r\n\t\tend)\r\n\tend)\r\n\r\n\tdescribe(\"Promise.new\", function()\r\n\t\tit(\"should instantiate with a callback\", function()\r\n\t\t\tlocal promise = Promise.new(function() end)\r\n\r\n\t\t\texpect(promise).to.be.ok()\r\n\t\tend)\r\n\r\n\t\tit(\"should invoke the given callback with resolve and reject\", function()\r\n\t\t\tlocal callCount = 0\r\n\t\t\tlocal resolveArg\r\n\t\t\tlocal rejectArg\r\n\r\n\t\t\tlocal promise = Promise.new(function(resolve, reject)\r\n\t\t\t\tcallCount = callCount + 1\r\n\t\t\t\tresolveArg = resolve\r\n\t\t\t\trejectArg = reject\r\n\t\t\tend)\r\n\r\n\t\t\texpect(promise).to.be.ok()\r\n\r\n\t\t\texpect(callCount).to.equal(1)\r\n\t\t\texpect(resolveArg).to.be.a(\"function\")\r\n\t\t\texpect(rejectArg).to.be.a(\"function\")\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Started)\r\n\t\tend)\r\n\r\n\t\tit(\"should resolve promises on resolve()\", function()\r\n\t\t\tlocal callCount = 0\r\n\r\n\t\t\tlocal promise = Promise.new(function(resolve)\r\n\t\t\t\tcallCount = callCount + 1\r\n\t\t\t\tresolve()\r\n\t\t\tend)\r\n\r\n\t\t\texpect(promise).to.be.ok()\r\n\t\t\texpect(callCount).to.equal(1)\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Resolved)\r\n\t\tend)\r\n\r\n\t\tit(\"should reject promises on reject()\", function()\r\n\t\t\tlocal callCount = 0\r\n\r\n\t\t\tlocal promise = Promise.new(function(resolve, reject)\r\n\t\t\t\tcallCount = callCount + 1\r\n\t\t\t\treject()\r\n\t\t\tend)\r\n\r\n\t\t\texpect(promise).to.be.ok()\r\n\t\t\texpect(callCount).to.equal(1)\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Rejected)\r\n\t\tend)\r\n\r\n\t\tit(\"should reject on error in callback\", function()\r\n\t\t\tlocal callCount = 0\r\n\r\n\t\t\tlocal promise = Promise.new(function()\r\n\t\t\t\tcallCount = callCount + 1\r\n\t\t\t\terror(\"hahah\")\r\n\t\t\tend)\r\n\r\n\t\t\texpect(promise).to.be.ok()\r\n\t\t\texpect(callCount).to.equal(1)\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Rejected)\r\n\t\t\texpect(tostring(promise._values[1]):find(\"hahah\")).to.be.ok()\r\n\r\n\t\t\t-- Loosely check for the pieces of the stack trace we expect\r\n\t\t\texpect(tostring(promise._values[1]):find(\"init.spec\")).to.be.ok()\r\n\t\t\texpect(tostring(promise._values[1]):find(\"runExecutor\")).to.be.ok()\r\n\t\tend)\r\n\r\n\t\tit(\"should work with C functions\", function()\r\n\t\t\texpect(function()\r\n\t\t\t\tPromise.new(tick):andThen(tick)\r\n\t\t\tend).to.never.throw()\r\n\t\tend)\r\n\r\n\t\tit(\"should have a nice tostring\", function()\r\n\t\t\texpect(tostring(Promise.resolve()):gmatch(\"Promise(Resolved)\")).to.be.ok()\r\n\t\tend)\r\n\r\n\t\tit(\"should allow yielding\", function()\r\n\t\t\tlocal bindable = Instance.new(\"BindableEvent\")\r\n\t\t\tlocal promise = Promise.new(function(resolve)\r\n\t\t\t\tbindable.Event:Wait()\r\n\t\t\t\tresolve(5)\r\n\t\t\tend)\r\n\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Started)\r\n\t\t\tbindable:Fire()\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Resolved)\r\n\t\t\texpect(promise._values[1]).to.equal(5)\r\n\t\tend)\r\n\r\n\t\tit(\"should preserve stack traces of resolve-chained promises\", function()\r\n\t\t\tlocal function nestedCall(text)\r\n\t\t\t\terror(text)\r\n\t\t\tend\r\n\r\n\t\t\tlocal promise = Promise.new(function(resolve)\r\n\t\t\t\tresolve(Promise.new(function()\r\n\t\t\t\t\tnestedCall(\"sample text\")\r\n\t\t\t\tend))\r\n\t\t\tend)\r\n\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Rejected)\r\n\r\n\t\t\tlocal trace = tostring(promise._values[1])\r\n\t\t\texpect(trace:find(\"sample text\")).to.be.ok()\r\n\t\t\texpect(trace:find(\"nestedCall\")).to.be.ok()\r\n\t\t\texpect(trace:find(\"runExecutor\")).to.be.ok()\r\n\t\t\texpect(trace:find(\"runPlanNode\")).to.be.ok()\r\n\t\t\texpect(trace:find(\"...Rejected because it was chained to the following Promise, which encountered an error:\")).to.be.ok()\r\n\t\tend)\r\n\r\n\t\tit(\"should report errors from Promises with _error (< v2)\", function()\r\n\t\t\tlocal oldPromise = Promise.reject()\r\n\t\t\toldPromise._error = \"Sample error\"\r\n\r\n\t\t\tlocal newPromise = Promise.resolve():andThenReturn(oldPromise)\r\n\r\n\t\t\texpect(newPromise:getStatus()).to.equal(Promise.Status.Rejected)\r\n\r\n\t\t\tlocal trace = tostring(newPromise._values[1])\r\n\t\t\texpect(trace:find(\"Sample error\")).to.be.ok()\r\n\t\t\texpect(trace:find(\"...Rejected because it was chained to the following Promise, which encountered an error:\")).to.be.ok()\r\n\t\t\texpect(trace:find(\"%[No stack trace available\")).to.be.ok()\r\n\t\tend)\r\n\tend)\r\n\r\n\tdescribe(\"Promise.defer\", function()\r\n\t\tit(\"should execute after the time event\", function()\r\n\t\t\tlocal callCount = 0\r\n\t\t\tlocal promise = Promise.defer(function(resolve, reject, onCancel, nothing)\r\n\t\t\t\texpect(type(resolve)).to.equal(\"function\")\r\n\t\t\t\texpect(type(reject)).to.equal(\"function\")\r\n\t\t\t\texpect(type(onCancel)).to.equal(\"function\")\r\n\t\t\t\texpect(type(nothing)).to.equal(\"nil\")\r\n\r\n\t\t\t\tcallCount = callCount + 1\r\n\r\n\t\t\t\tresolve(\"foo\")\r\n\t\t\tend)\r\n\r\n\t\t\texpect(callCount).to.equal(0)\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Started)\r\n\r\n\t\t\tadvanceTime()\r\n\t\t\texpect(callCount).to.equal(1)\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Resolved)\r\n\r\n\t\t\tadvanceTime()\r\n\t\t\texpect(callCount).to.equal(1)\r\n\t\tend)\r\n\tend)\r\n\r\n\tdescribe(\"Promise.delay\", function()\r\n\t\tit(\"should schedule promise resolution\", function()\r\n\t\t\tlocal promise = Promise.delay(1)\r\n\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Started)\r\n\r\n\t\t\tadvanceTime()\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Started)\r\n\r\n\t\t\tadvanceTime(1)\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Resolved)\r\n\t\tend)\r\n\r\n\t\tit(\"should allow for delays to be cancelled\", function()\r\n\t\t\tlocal promise = Promise.delay(2)\r\n\r\n\t\t\tPromise.delay(1):andThen(function()\r\n\t\t\t    promise:cancel()\r\n\t\t\tend)\r\n\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Started)\r\n\t\t\tadvanceTime()\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Started)\r\n\t\t\tadvanceTime(1)\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Cancelled)\r\n\t\t\tadvanceTime(1)\r\n\t\tend)\r\n\tend)\r\n\r\n\tdescribe(\"Promise.resolve\", function()\r\n\t\tit(\"should immediately resolve with a value\", function()\r\n\t\t\tlocal promise = Promise.resolve(5, 6)\r\n\r\n\t\t\texpect(promise).to.be.ok()\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Resolved)\r\n\t\t\texpect(promise._values[1]).to.equal(5)\r\n\t\t\texpect(promise._values[2]).to.equal(6)\r\n\t\tend)\r\n\r\n\t\tit(\"should chain onto passed promises\", function()\r\n\t\t\tlocal promise = Promise.resolve(Promise.new(function(_, reject)\r\n\t\t\t\treject(7)\r\n\t\t\tend))\r\n\r\n\t\t\texpect(promise).to.be.ok()\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Rejected)\r\n\t\t\texpect(promise._values[1]).to.equal(7)\r\n\t\tend)\r\n\tend)\r\n\r\n\tdescribe(\"Promise.reject\", function()\r\n\t\tit(\"should immediately reject with a value\", function()\r\n\t\t\tlocal promise = Promise.reject(6, 7)\r\n\r\n\t\t\texpect(promise).to.be.ok()\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Rejected)\r\n\t\t\texpect(promise._values[1]).to.equal(6)\r\n\t\t\texpect(promise._values[2]).to.equal(7)\r\n\t\tend)\r\n\r\n\t\tit(\"should pass a promise as-is as an error\", function()\r\n\t\t\tlocal innerPromise = Promise.new(function(resolve)\r\n\t\t\t\tresolve(6)\r\n\t\t\tend)\r\n\r\n\t\t\tlocal promise = Promise.reject(innerPromise)\r\n\r\n\t\t\texpect(promise).to.be.ok()\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Rejected)\r\n\t\t\texpect(promise._values[1]).to.equal(innerPromise)\r\n\t\tend)\r\n\tend)\r\n\r\n\tdescribe(\"Promise:andThen\", function()\r\n\t\tit(\"should allow yielding\", function()\r\n\t\t\tlocal bindable = Instance.new(\"BindableEvent\")\r\n\t\t\tlocal promise = Promise.resolve():andThen(function()\r\n\t\t\t\tbindable.Event:Wait()\r\n\t\t\t\treturn 5\r\n\t\t\tend)\r\n\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Started)\r\n\t\t\tbindable:Fire()\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Resolved)\r\n\t\t\texpect(promise._values[1]).to.equal(5)\r\n\t\tend)\r\n\r\n\t\tit(\"should run andThens on a new thread\", function()\r\n\t\t\tlocal bindable = Instance.new(\"BindableEvent\")\r\n\r\n\t\t\tlocal resolve\r\n\t\t\tlocal parentPromise = Promise.new(function(_resolve)\r\n\t\t\t\tresolve = _resolve\r\n\t\t\tend)\r\n\r\n\t\t\tlocal deadlockedPromise = parentPromise:andThen(function()\r\n\t\t\t\tbindable.Event:Wait()\r\n\t\t\t\treturn 5\r\n\t\t\tend)\r\n\r\n\t\t\tlocal successfulPromise = parentPromise:andThen(function()\r\n\t\t\t\treturn \"foo\"\r\n\t\t\tend)\r\n\r\n\t\t\texpect(parentPromise:getStatus()).to.equal(Promise.Status.Started)\r\n\t\t\tresolve()\r\n\t\t\texpect(successfulPromise:getStatus()).to.equal(Promise.Status.Resolved)\r\n\t\t\texpect(successfulPromise._values[1]).to.equal(\"foo\")\r\n\t\t\texpect(deadlockedPromise:getStatus()).to.equal(Promise.Status.Started)\r\n\t\tend)\r\n\r\n\t\tit(\"should chain onto resolved promises\", function()\r\n\t\t\tlocal args\r\n\t\t\tlocal argsLength\r\n\t\t\tlocal callCount = 0\r\n\t\t\tlocal badCallCount = 0\r\n\r\n\t\t\tlocal promise = Promise.resolve(5)\r\n\r\n\t\t\tlocal chained = promise:andThen(\r\n\t\t\t\tfunction(...)\r\n\t\t\t\t\targsLength, args = pack(...)\r\n\t\t\t\t\tcallCount = callCount + 1\r\n\t\t\t\tend,\r\n\t\t\t\tfunction()\r\n\t\t\t\t\tbadCallCount = badCallCount + 1\r\n\t\t\t\tend\r\n\t\t\t)\r\n\r\n\t\t\texpect(badCallCount).to.equal(0)\r\n\r\n\t\t\texpect(callCount).to.equal(1)\r\n\t\t\texpect(argsLength).to.equal(1)\r\n\t\t\texpect(args[1]).to.equal(5)\r\n\r\n\t\t\texpect(promise).to.be.ok()\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Resolved)\r\n\t\t\texpect(promise._values[1]).to.equal(5)\r\n\r\n\t\t\texpect(chained).to.be.ok()\r\n\t\t\texpect(chained).never.to.equal(promise)\r\n\t\t\texpect(chained:getStatus()).to.equal(Promise.Status.Resolved)\r\n\t\t\texpect(#chained._values).to.equal(0)\r\n\t\tend)\r\n\r\n\t\tit(\"should chain onto rejected promises\", function()\r\n\t\t\tlocal args\r\n\t\t\tlocal argsLength\r\n\t\t\tlocal callCount = 0\r\n\t\t\tlocal badCallCount = 0\r\n\r\n\t\t\tlocal promise = Promise.reject(5)\r\n\r\n\t\t\tlocal chained = promise:andThen(\r\n\t\t\t\tfunction(...)\r\n\t\t\t\t\tbadCallCount = badCallCount + 1\r\n\t\t\t\tend,\r\n\t\t\t\tfunction(...)\r\n\t\t\t\t\targsLength, args = pack(...)\r\n\t\t\t\t\tcallCount = callCount + 1\r\n\t\t\t\tend\r\n\t\t\t)\r\n\r\n\t\t\texpect(badCallCount).to.equal(0)\r\n\r\n\t\t\texpect(callCount).to.equal(1)\r\n\t\t\texpect(argsLength).to.equal(1)\r\n\t\t\texpect(args[1]).to.equal(5)\r\n\r\n\t\t\texpect(promise).to.be.ok()\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Rejected)\r\n\t\t\texpect(promise._values[1]).to.equal(5)\r\n\r\n\t\t\texpect(chained).to.be.ok()\r\n\t\t\texpect(chained).never.to.equal(promise)\r\n\t\t\texpect(chained:getStatus()).to.equal(Promise.Status.Resolved)\r\n\t\t\texpect(#chained._values).to.equal(0)\r\n\t\tend)\r\n\r\n\t\tit(\"should reject on error in callback\", function()\r\n\t\t\tlocal callCount = 0\r\n\r\n\t\t\tlocal promise = Promise.resolve(1):andThen(function()\r\n\t\t\t\tcallCount = callCount + 1\r\n\t\t\t\terror(\"hahah\")\r\n\t\t\tend)\r\n\r\n\t\t\texpect(promise).to.be.ok()\r\n\t\t\texpect(callCount).to.equal(1)\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Rejected)\r\n\t\t\texpect(tostring(promise._values[1]):find(\"hahah\")).to.be.ok()\r\n\r\n\t\t\t-- Loosely check for the pieces of the stack trace we expect\r\n\t\t\texpect(tostring(promise._values[1]):find(\"init.spec\")).to.be.ok()\r\n\t\t\texpect(tostring(promise._values[1]):find(\"runExecutor\")).to.be.ok()\r\n\t\tend)\r\n\r\n\t\tit(\"should chain onto asynchronously resolved promises\", function()\r\n\t\t\tlocal args\r\n\t\t\tlocal argsLength\r\n\t\t\tlocal callCount = 0\r\n\t\t\tlocal badCallCount = 0\r\n\r\n\t\t\tlocal startResolution\r\n\t\t\tlocal promise = Promise.new(function(resolve)\r\n\t\t\t\tstartResolution = resolve\r\n\t\t\tend)\r\n\r\n\t\t\tlocal chained = promise:andThen(\r\n\t\t\t\tfunction(...)\r\n\t\t\t\t\targs = {...}\r\n\t\t\t\t\targsLength = select(\"#\", ...)\r\n\t\t\t\t\tcallCount = callCount + 1\r\n\t\t\t\tend,\r\n\t\t\t\tfunction()\r\n\t\t\t\t\tbadCallCount = badCallCount + 1\r\n\t\t\t\tend\r\n\t\t\t)\r\n\r\n\t\t\texpect(callCount).to.equal(0)\r\n\t\t\texpect(badCallCount).to.equal(0)\r\n\r\n\t\t\tstartResolution(6)\r\n\r\n\t\t\texpect(badCallCount).to.equal(0)\r\n\r\n\t\t\texpect(callCount).to.equal(1)\r\n\t\t\texpect(argsLength).to.equal(1)\r\n\t\t\texpect(args[1]).to.equal(6)\r\n\r\n\t\t\texpect(promise).to.be.ok()\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Resolved)\r\n\t\t\texpect(promise._values[1]).to.equal(6)\r\n\r\n\t\t\texpect(chained).to.be.ok()\r\n\t\t\texpect(chained).never.to.equal(promise)\r\n\t\t\texpect(chained:getStatus()).to.equal(Promise.Status.Resolved)\r\n\t\t\texpect(#chained._values).to.equal(0)\r\n\t\tend)\r\n\r\n\t\tit(\"should chain onto asynchronously rejected promises\", function()\r\n\t\t\tlocal args\r\n\t\t\tlocal argsLength\r\n\t\t\tlocal callCount = 0\r\n\t\t\tlocal badCallCount = 0\r\n\r\n\t\t\tlocal startResolution\r\n\t\t\tlocal promise = Promise.new(function(_, reject)\r\n\t\t\t\tstartResolution = reject\r\n\t\t\tend)\r\n\r\n\t\t\tlocal chained = promise:andThen(\r\n\t\t\t\tfunction()\r\n\t\t\t\t\tbadCallCount = badCallCount + 1\r\n\t\t\t\tend,\r\n\t\t\t\tfunction(...)\r\n\t\t\t\t\targs = {...}\r\n\t\t\t\t\targsLength = select(\"#\", ...)\r\n\t\t\t\t\tcallCount = callCount + 1\r\n\t\t\t\tend\r\n\t\t\t)\r\n\r\n\t\t\texpect(callCount).to.equal(0)\r\n\t\t\texpect(badCallCount).to.equal(0)\r\n\r\n\t\t\tstartResolution(6)\r\n\r\n\t\t\texpect(badCallCount).to.equal(0)\r\n\r\n\t\t\texpect(callCount).to.equal(1)\r\n\t\t\texpect(argsLength).to.equal(1)\r\n\t\t\texpect(args[1]).to.equal(6)\r\n\r\n\t\t\texpect(promise).to.be.ok()\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Rejected)\r\n\t\t\texpect(promise._values[1]).to.equal(6)\r\n\r\n\t\t\texpect(chained).to.be.ok()\r\n\t\t\texpect(chained).never.to.equal(promise)\r\n\t\t\texpect(chained:getStatus()).to.equal(Promise.Status.Resolved)\r\n\t\t\texpect(#chained._values).to.equal(0)\r\n\t\tend)\r\n\r\n\t\tit(\"should propagate errors through multiple levels\", function()\r\n\t\t\tlocal x, y, z\r\n\t\t\tPromise.new(function(resolve, reject)\r\n\t\t\t\treject(1, 2, 3)\r\n\t\t\tend)\r\n\t\t\t:andThen(function() end)\r\n\t\t\t:catch(function(a, b, c)\r\n\t\t\t\tx, y, z = a, b, c\r\n\t\t\tend)\r\n\r\n\t\t\texpect(x).to.equal(1)\r\n\t\t\texpect(y).to.equal(2)\r\n\t\t\texpect(z).to.equal(3)\r\n\t\tend)\r\n\tend)\r\n\r\n\tdescribe(\"Promise:cancel\", function()\r\n\t\tit(\"should mark promises as cancelled and not resolve or reject them\", function()\r\n\t\t\tlocal callCount = 0\r\n\t\t\tlocal finallyCallCount = 0\r\n\t\t\tlocal promise = Promise.new(function() end):andThen(function()\r\n\t\t\t\tcallCount = callCount + 1\r\n\t\t\tend):finally(function()\r\n\t\t\t\tfinallyCallCount = finallyCallCount + 1\r\n\t\t\tend)\r\n\r\n\t\t\tpromise:cancel()\r\n\t\t\tpromise:cancel() -- Twice to check call counts\r\n\r\n\t\t\texpect(callCount).to.equal(0)\r\n\t\t\texpect(finallyCallCount).to.equal(1)\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Cancelled)\r\n\t\tend)\r\n\r\n\t\tit(\"should call the cancellation hook once\", function()\r\n\t\t\tlocal callCount = 0\r\n\r\n\t\t\tlocal promise = Promise.new(function(resolve, reject, onCancel)\r\n\t\t\t\tonCancel(function()\r\n\t\t\t\t\tcallCount = callCount + 1\r\n\t\t\t\tend)\r\n\t\t\tend)\r\n\r\n\t\t\tpromise:cancel()\r\n\t\t\tpromise:cancel() -- Twice to check call count\r\n\r\n\t\t\texpect(callCount).to.equal(1)\r\n\t\tend)\r\n\r\n\t\tit(\"should propagate cancellations\", function()\r\n\t\t\tlocal promise = Promise.new(function() end)\r\n\r\n\t\t\tlocal consumer1 = promise:andThen()\r\n\t\t\tlocal consumer2 = promise:andThen()\r\n\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Started)\r\n\t\t\texpect(consumer1:getStatus()).to.equal(Promise.Status.Started)\r\n\t\t\texpect(consumer2:getStatus()).to.equal(Promise.Status.Started)\r\n\r\n\t\t\tconsumer1:cancel()\r\n\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Started)\r\n\t\t\texpect(consumer1:getStatus()).to.equal(Promise.Status.Cancelled)\r\n\t\t\texpect(consumer2:getStatus()).to.equal(Promise.Status.Started)\r\n\r\n\t\t\tconsumer2:cancel()\r\n\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Cancelled)\r\n\t\t\texpect(consumer1:getStatus()).to.equal(Promise.Status.Cancelled)\r\n\t\t\texpect(consumer2:getStatus()).to.equal(Promise.Status.Cancelled)\r\n\t\tend)\r\n\r\n\t\tit(\"should affect downstream promises\", function()\r\n\t\t\tlocal promise = Promise.new(function() end)\r\n\t\t\tlocal consumer = promise:andThen()\r\n\r\n\t\t\tpromise:cancel()\r\n\r\n\t\t\texpect(consumer:getStatus()).to.equal(Promise.Status.Cancelled)\r\n\t\tend)\r\n\r\n\t\tit(\"should track consumers\", function()\r\n\t\t\tlocal pending = Promise.new(function() end)\r\n\t\t\tlocal p0 = Promise.resolve()\r\n\t\t\tlocal p1 = p0:finally(function() return pending end)\r\n\t\t\tlocal p2 = Promise.new(function(resolve)\r\n\t\t\t\tresolve(p1)\r\n\t\t\tend)\r\n\t\t\tlocal p3 = p2:andThen(function() end)\r\n\r\n\t\t\texpect(p1._parent).to.never.equal(p0)\r\n\t\t\texpect(p2._parent).to.never.equal(p1)\r\n\t\t\texpect(p2._consumers[p3]).to.be.ok()\r\n\t\t\texpect(p3._parent).to.equal(p2)\r\n\t\tend)\r\n\r\n\t\tit(\"should cancel resolved pending promises\", function()\r\n\t\t\tlocal p1 = Promise.new(function() end)\r\n\r\n\t\t\tlocal p2 = Promise.new(function(resolve)\r\n\t\t\t\tresolve(p1)\r\n\t\t\tend):finally(function() end)\r\n\r\n\t\t\tp2:cancel()\r\n\r\n\t\t\texpect(p1._status).to.equal(Promise.Status.Cancelled)\r\n\t\t\texpect(p2._status).to.equal(Promise.Status.Cancelled)\r\n\t\tend)\r\n\tend)\r\n\r\n\tdescribe(\"Promise:finally\", function()\r\n\t\tit(\"should be called upon resolve, reject, or cancel\", function()\r\n\t\t\tlocal callCount = 0\r\n\r\n\t\t\tlocal function finally()\r\n\t\t\t\tcallCount = callCount + 1\r\n\t\t\tend\r\n\r\n\t\t\t-- Resolved promise\r\n\t\t\tPromise.new(function(resolve, reject)\r\n\t\t\t\tresolve()\r\n\t\t\tend):finally(finally)\r\n\r\n\t\t\t-- Chained promise\r\n\t\t\tPromise.resolve():andThen(function()\r\n\r\n\t\t\tend):finally(finally):finally(finally)\r\n\r\n\t\t\t-- Rejected promise\r\n\t\t\tPromise.reject():finally(finally)\r\n\r\n\t\t\tlocal cancelledPromise = Promise.new(function() end):finally(finally)\r\n\t\t\tcancelledPromise:cancel()\r\n\r\n\t\t\texpect(callCount).to.equal(5)\r\n\t\tend)\r\n\r\n\t\tit(\"should be a child of the parent Promise\", function()\r\n\t\t\tlocal p1 = Promise.new(function() end)\r\n\t\t\tlocal p2 = p1:finally(function() end)\r\n\r\n\t\t\texpect(p2._parent).to.equal(p1)\r\n\t\t\texpect(p1._consumers[p2]).to.equal(true)\r\n\t\tend)\r\n\r\n\t\tit(\"should forward return values\", function()\r\n\t\t\tlocal value\r\n\r\n\t\t\tPromise.resolve():finally(function()\r\n\t\t\t\treturn 1\r\n\t\t\tend):andThen(function(v)\r\n\t\t\t\tvalue = v\r\n\t\t\tend)\r\n\r\n\t\t\texpect(value).to.equal(1)\r\n\t\tend)\r\n\tend)\r\n\r\n\tdescribe(\"Promise.all\", function()\r\n\t\tit(\"should error if given something other than a table\", function()\r\n\t\t\texpect(function()\r\n\t\t\t\tPromise.all(1)\r\n\t\t\tend).to.throw()\r\n\t\tend)\r\n\r\n\t\tit(\"should resolve instantly with an empty table if given no promises\", function()\r\n\t\t\tlocal promise = Promise.all({})\r\n\t\t\tlocal success, value = promise:_unwrap()\r\n\r\n\t\t\texpect(success).to.equal(true)\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Resolved)\r\n\t\t\texpect(value).to.be.a(\"table\")\r\n\t\t\texpect(next(value)).to.equal(nil)\r\n\t\tend)\r\n\r\n\t\tit(\"should error if given non-promise values\", function()\r\n\t\t\texpect(function()\r\n\t\t\t\tPromise.all({{}, {}, {}})\r\n\t\t\tend).to.throw()\r\n\t\tend)\r\n\r\n\t\tit(\"should wait for all promises to be resolved and return their values\", function()\r\n\t\t\tlocal resolveFunctions = {}\r\n\r\n\t\t\tlocal testValuesLength, testValues = pack(1, \"A string\", nil, false)\r\n\r\n\t\t\tlocal promises = {}\r\n\r\n\t\t\tfor i = 1, testValuesLength do\r\n\t\t\t\tpromises[i] = Promise.new(function(resolve)\r\n\t\t\t\t\tresolveFunctions[i] = {resolve, testValues[i]}\r\n\t\t\t\tend)\r\n\t\t\tend\r\n\r\n\t\t\tlocal combinedPromise = Promise.all(promises)\r\n\r\n\t\t\tfor _, resolve in ipairs(resolveFunctions) do\r\n\t\t\t\texpect(combinedPromise:getStatus()).to.equal(Promise.Status.Started)\r\n\t\t\t\tresolve[1](resolve[2])\r\n\t\t\tend\r\n\r\n\t\t\tlocal resultLength, result = pack(combinedPromise:_unwrap())\r\n\t\t\tlocal success, resolved = unpack(result, 1, resultLength)\r\n\r\n\t\t\texpect(resultLength).to.equal(2)\r\n\t\t\texpect(success).to.equal(true)\r\n\t\t\texpect(resolved).to.be.a(\"table\")\r\n\t\t\texpect(#resolved).to.equal(#promises)\r\n\r\n\t\t\tfor i = 1, testValuesLength do\r\n\t\t\t\texpect(resolved[i]).to.equal(testValues[i])\r\n\t\t\tend\r\n\t\tend)\r\n\r\n\t\tit(\"should reject if any individual promise rejected\", function()\r\n\t\t\tlocal rejectA\r\n\t\t\tlocal resolveB\r\n\r\n\t\t\tlocal a = Promise.new(function(_, reject)\r\n\t\t\t\trejectA = reject\r\n\t\t\tend)\r\n\r\n\t\t\tlocal b = Promise.new(function(resolve)\r\n\t\t\t\tresolveB = resolve\r\n\t\t\tend)\r\n\r\n\t\t\tlocal combinedPromise = Promise.all({a, b})\r\n\r\n\t\t\texpect(combinedPromise:getStatus()).to.equal(Promise.Status.Started)\r\n\r\n\t\t\trejectA(\"baz\", \"qux\")\r\n\t\t\tresolveB(\"foo\", \"bar\")\r\n\r\n\t\t\tlocal resultLength, result = pack(combinedPromise:_unwrap())\r\n\t\t\tlocal success, first, second = unpack(result, 1, resultLength)\r\n\r\n\t\t\texpect(resultLength).to.equal(3)\r\n\t\t\texpect(success).to.equal(false)\r\n\t\t\texpect(first).to.equal(\"baz\")\r\n\t\t\texpect(second).to.equal(\"qux\")\r\n\t\t\texpect(b:getStatus()).to.equal(Promise.Status.Cancelled)\r\n\t\tend)\r\n\r\n\t\tit(\"should not resolve if resolved after rejecting\", function()\r\n\t\t\tlocal rejectA\r\n\t\t\tlocal resolveB\r\n\r\n\t\t\tlocal a = Promise.new(function(_, reject)\r\n\t\t\t\trejectA = reject\r\n\t\t\tend)\r\n\r\n\t\t\tlocal b = Promise.new(function(resolve)\r\n\t\t\t\tresolveB = resolve\r\n\t\t\tend)\r\n\r\n\t\t\tlocal combinedPromise = Promise.all({a, b})\r\n\r\n\t\t\texpect(combinedPromise:getStatus()).to.equal(Promise.Status.Started)\r\n\r\n\t\t\trejectA(\"baz\", \"qux\")\r\n\t\t\tresolveB(\"foo\", \"bar\")\r\n\r\n\t\t\tlocal resultLength, result = pack(combinedPromise:_unwrap())\r\n\t\t\tlocal success, first, second = unpack(result, 1, resultLength)\r\n\r\n\t\t\texpect(resultLength).to.equal(3)\r\n\t\t\texpect(success).to.equal(false)\r\n\t\t\texpect(first).to.equal(\"baz\")\r\n\t\t\texpect(second).to.equal(\"qux\")\r\n\t\tend)\r\n\r\n\t\tit(\"should only reject once\", function()\r\n\t\t\tlocal rejectA\r\n\t\t\tlocal rejectB\r\n\r\n\t\t\tlocal a = Promise.new(function(_, reject)\r\n\t\t\t\trejectA = reject\r\n\t\t\tend)\r\n\r\n\t\t\tlocal b = Promise.new(function(_, reject)\r\n\t\t\t\trejectB = reject\r\n\t\t\tend)\r\n\r\n\t\t\tlocal combinedPromise = Promise.all({a, b})\r\n\r\n\t\t\texpect(combinedPromise:getStatus()).to.equal(Promise.Status.Started)\r\n\r\n\t\t\trejectA(\"foo\", \"bar\")\r\n\r\n\t\t\texpect(combinedPromise:getStatus()).to.equal(Promise.Status.Rejected)\r\n\r\n\t\t\trejectB(\"baz\", \"qux\")\r\n\r\n\t\t\tlocal resultLength, result = pack(combinedPromise:_unwrap())\r\n\t\t\tlocal success, first, second = unpack(result, 1, resultLength)\r\n\r\n\t\t\texpect(resultLength).to.equal(3)\r\n\t\t\texpect(success).to.equal(false)\r\n\t\t\texpect(first).to.equal(\"foo\")\r\n\t\t\texpect(second).to.equal(\"bar\")\r\n\t\tend)\r\n\r\n\t\tit(\"should error if a non-array table is passed in\", function()\r\n\t\t\tlocal ok, err = pcall(function()\r\n\t\t\t\tPromise.all(Promise.new(function() end))\r\n\t\t\tend)\r\n\r\n\t\t\texpect(ok).to.be.ok()\r\n\t\t\texpect(err:find(\"Non%-promise\")).to.be.ok()\r\n\t\tend)\r\n\r\n\t\tit(\"should cancel pending promises if one rejects\", function()\r\n\t\t\tlocal p = Promise.new(function() end)\r\n\t\t\texpect(Promise.all({\r\n\t\t\t\tPromise.resolve(),\r\n\t\t\t\tPromise.reject(),\r\n\t\t\t\tp\r\n\t\t\t}):getStatus()).to.equal(Promise.Status.Rejected)\r\n\t\t\texpect(p:getStatus()).to.equal(Promise.Status.Cancelled)\r\n\t\tend)\r\n\r\n\t\tit(\"should cancel promises if it is cancelled\", function()\r\n\t\t\tlocal p = Promise.new(function() end)\r\n\t\t\tp:andThen(function() end)\r\n\r\n\t\t\tlocal promises = {\r\n\t\t\t\tPromise.new(function() end),\r\n\t\t\t\tPromise.new(function() end),\r\n\t\t\t\tp\r\n\t\t\t}\r\n\r\n\t\t\tPromise.all(promises):cancel()\r\n\r\n\t\t\texpect(promises[1]:getStatus()).to.equal(Promise.Status.Cancelled)\r\n\t\t\texpect(promises[2]:getStatus()).to.equal(Promise.Status.Cancelled)\r\n\t\t\texpect(promises[3]:getStatus()).to.equal(Promise.Status.Started)\r\n\t\tend)\r\n\tend)\r\n\r\n\tdescribe(\"Promise.fold\", function()\r\n\t\tit(\"should return the initial value in a promise when the list is empty\", function()\r\n\t\t\tlocal initialValue = {}\r\n\t\t\tlocal result = Promise.fold({}, function()\r\n\t\t\t\terror(\"should not be called\")\r\n\t\t\tend, initialValue)\r\n\r\n\t\t\texpect(Promise.is(result)).to.equal(true)\r\n\t\t\texpect(result:getStatus()).to.equal(Promise.Status.Resolved)\r\n\t\t\texpect(result:expect()).to.equal(initialValue)\r\n\t\tend)\r\n\r\n\t\tit(\"should accept promises in the list\", function()\r\n\t\t\tlocal sum = Promise.fold({Promise.resolve(1), 2, 3}, function(sum, element)\r\n\t\t\t\treturn sum + element\r\n\t\t\tend, 0)\r\n\t\t\texpect(Promise.is(sum)).to.equal(true)\r\n\t\t\texpect(sum:getStatus()).to.equal(Promise.Status.Resolved)\r\n\t\t\texpect(sum:expect()).to.equal(6)\r\n\t\tend)\r\n\r\n\t\tit(\"should always return a promise even if the list or reducer don't use them\", function()\r\n\t\t\tlocal sum = Promise.fold({1, 2, 3}, function(sum, element, index)\r\n\t\t\t\tif index == 2 then\r\n\t\t\t\t\treturn Promise.delay(1):andThenReturn(sum + element)\r\n\t\t\t\telse\r\n\t\t\t\t\treturn sum + element\r\n\t\t\t\tend\r\n\t\t\tend, 0)\r\n\t\t\texpect(Promise.is(sum)).to.equal(true)\r\n\t\t\texpect(sum:getStatus()).to.equal(Promise.Status.Started)\r\n\t\t\tadvanceTime(2)\r\n\t\t\texpect(sum:getStatus()).to.equal(Promise.Status.Resolved)\r\n\t\t\texpect(sum:expect()).to.equal(6)\r\n\t\tend)\r\n\r\n\t\tit(\"should return the first rejected promise\", function()\r\n\t\t\tlocal errorMessage = \"foo\"\r\n\t\t\tlocal sum = Promise.fold({1, 2, 3}, function(sum, element, index)\r\n\t\t\t\tif index == 2 then\r\n\t\t\t\t\treturn Promise.reject(errorMessage)\r\n\t\t\t\telse\r\n\t\t\t\t\treturn sum + element\r\n\t\t\t\tend\r\n\t\t\tend, 0)\r\n\t\t\texpect(Promise.is(sum)).to.equal(true)\r\n\t\t\tlocal status, rejection = sum:awaitStatus()\r\n\t\t\texpect(status).to.equal(Promise.Status.Rejected)\r\n\t\t\texpect(rejection).to.equal(errorMessage)\r\n\t\tend)\r\n\r\n\t\tit(\"should return the first canceled promise\", function()\r\n\t\t\tlocal secondPromise\r\n\t\t\tlocal sum = Promise.fold({1, 2, 3}, function(sum, element, index)\r\n\t\t\t\tif index == 1 then\r\n\t\t\t\t\treturn sum + element\r\n\t\t\t\telseif index == 2 then\r\n\t\t\t\t\tsecondPromise = Promise.delay(1):andThenReturn(sum + element)\r\n\t\t\t\t\treturn secondPromise\r\n\t\t\t\telse\r\n\t\t\t\t\terror('this should not run if the promise is cancelled')\r\n\t\t\t\tend\r\n\t\t\tend, 0)\r\n\t\t\texpect(Promise.is(sum)).to.equal(true)\r\n\t\t\texpect(sum:getStatus()).to.equal(Promise.Status.Started)\r\n\t\t\tsecondPromise:cancel()\r\n\t\t\texpect(sum:getStatus()).to.equal(Promise.Status.Cancelled)\r\n\t\tend)\r\n\tend)\r\n\r\n\tdescribe(\"Promise.race\", function()\r\n\t\tit(\"should resolve with the first settled value\", function()\r\n\t\t\tlocal promise = Promise.race({\r\n\t\t\t\tPromise.resolve(1),\r\n\t\t\t\tPromise.resolve(2)\r\n\t\t\t}):andThen(function(value)\r\n\t\t\t\texpect(value).to.equal(1)\r\n\t\t\tend)\r\n\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Resolved)\r\n\t\tend)\r\n\r\n\t\tit(\"should cancel other promises\", function()\r\n\t\t\tlocal promise = Promise.new(function() end)\r\n\t\t\tpromise:andThen(function() end)\r\n\t\t\tlocal promises = {\r\n\t\t\t\tpromise,\r\n\t\t\t\tPromise.new(function() end),\r\n\t\t\t\tPromise.new(function(resolve)\r\n\t\t\t\t\tresolve(2)\r\n\t\t\t\tend)\r\n\t\t\t}\r\n\r\n\t\t\tlocal promise = Promise.race(promises)\r\n\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Resolved)\r\n\t\t\texpect(promise._values[1]).to.equal(2)\r\n\t\t\texpect(promises[1]:getStatus()).to.equal(Promise.Status.Started)\r\n\t\t\texpect(promises[2]:getStatus()).to.equal(Promise.Status.Cancelled)\r\n\t\t\texpect(promises[3]:getStatus()).to.equal(Promise.Status.Resolved)\r\n\r\n\t\t\tlocal p = Promise.new(function() end)\r\n\t\t\texpect(Promise.race({\r\n\t\t\t\tPromise.reject(),\r\n\t\t\t\tPromise.resolve(),\r\n\t\t\t\tp\r\n\t\t\t}):getStatus()).to.equal(Promise.Status.Rejected)\r\n\t\t\texpect(p:getStatus()).to.equal(Promise.Status.Cancelled)\r\n\t\tend)\r\n\r\n\t\tit(\"should error if a non-array table is passed in\", function()\r\n\t\t\tlocal ok, err = pcall(function()\r\n\t\t\t\tPromise.race(Promise.new(function() end))\r\n\t\t\tend)\r\n\r\n\t\t\texpect(ok).to.be.ok()\r\n\t\t\texpect(err:find(\"Non%-promise\")).to.be.ok()\r\n\t\tend)\r\n\r\n\t\tit(\"should cancel promises if it is cancelled\", function()\r\n\t\t\tlocal p = Promise.new(function() end)\r\n\t\t\tp:andThen(function() end)\r\n\r\n\t\t\tlocal promises = {\r\n\t\t\t\tPromise.new(function() end),\r\n\t\t\t\tPromise.new(function() end),\r\n\t\t\t\tp\r\n\t\t\t}\r\n\r\n\t\t\tPromise.race(promises):cancel()\r\n\r\n\t\t\texpect(promises[1]:getStatus()).to.equal(Promise.Status.Cancelled)\r\n\t\t\texpect(promises[2]:getStatus()).to.equal(Promise.Status.Cancelled)\r\n\t\t\texpect(promises[3]:getStatus()).to.equal(Promise.Status.Started)\r\n\t\tend)\r\n\tend)\r\n\r\n\tdescribe(\"Promise.promisify\", function()\r\n\t\tit(\"should wrap functions\", function()\r\n\t\t\tlocal function test(n)\r\n\t\t\t\treturn n + 1\r\n\t\t\tend\r\n\r\n\t\t\tlocal promisified = Promise.promisify(test)\r\n\t\t\tlocal promise = promisified(1)\r\n\t\t\tlocal success, result = promise:_unwrap()\r\n\r\n\t\t\texpect(success).to.equal(true)\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Resolved)\r\n\t\t\texpect(result).to.equal(2)\r\n\t\tend)\r\n\r\n\t\tit(\"should catch errors after a yield\", function()\r\n\t\t\tlocal bindable = Instance.new(\"BindableEvent\")\r\n\t\t\tlocal test = Promise.promisify(function ()\r\n\t\t\t\tbindable.Event:Wait()\r\n\t\t\t\terror('errortext')\r\n\t\t\tend)\r\n\r\n\t\t\tlocal promise = test()\r\n\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Started)\r\n\t\t\tbindable:Fire()\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Rejected)\r\n\t\t\texpect(tostring(promise._values[1]):find(\"errortext\")).to.be.ok()\r\n\t\tend)\r\n\tend)\r\n\r\n\tdescribe(\"Promise.tap\", function()\r\n\t\tit(\"should thread through values\", function()\r\n\t\t\tlocal first, second\r\n\r\n\t\t\tPromise.resolve(1)\r\n\t\t\t\t:andThen(function(v)\r\n\t\t\t\t\treturn v + 1\r\n\t\t\t\tend)\r\n\t\t\t\t:tap(function(v)\r\n\t\t\t\t\tfirst = v\r\n\t\t\t\t\treturn v + 1\r\n\t\t\t\tend)\r\n\t\t\t\t:andThen(function(v)\r\n\t\t\t\t\tsecond = v\r\n\t\t\t\tend)\r\n\r\n\t\t\texpect(first).to.equal(2)\r\n\t\t\texpect(second).to.equal(2)\r\n\t\tend)\r\n\r\n\t\tit(\"should chain onto promises\", function()\r\n\t\t\tlocal resolveInner, finalValue\r\n\r\n\t\t\tlocal promise = Promise.resolve(1)\r\n\t\t\t\t:tap(function()\r\n\t\t\t\t\treturn Promise.new(function(resolve)\r\n\t\t\t\t\t\tresolveInner = resolve\r\n\t\t\t\t\tend)\r\n\t\t\t\tend)\r\n\t\t\t\t:andThen(function(v)\r\n\t\t\t\t\tfinalValue = v\r\n\t\t\t\tend)\r\n\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Started)\r\n\t\t\texpect(finalValue).to.never.be.ok()\r\n\r\n\t\t\tresolveInner(1)\r\n\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Resolved)\r\n\t\t\texpect(finalValue).to.equal(1)\r\n\t\tend)\r\n\tend)\r\n\r\n\tdescribe(\"Promise.try\", function()\r\n\t\tit(\"should catch synchronous errors\", function()\r\n\t\t\tlocal errorText\r\n\t\t\tPromise.try(function()\r\n\t\t\t\terror('errortext')\r\n\t\t\tend):catch(function(e)\r\n\t\t\t\terrorText = tostring(e)\r\n\t\t\tend)\r\n\r\n\t\t\texpect(errorText:find(\"errortext\")).to.be.ok()\r\n\t\tend)\r\n\r\n\t\tit(\"should reject with error objects\", function()\r\n\t\t\tlocal object = {}\r\n\t\t\tlocal success, value = Promise.try(function()\r\n\t\t\t\terror(object)\r\n\t\t\tend):_unwrap()\r\n\r\n\t\t\texpect(success).to.equal(false)\r\n\t\t\texpect(value).to.equal(object)\r\n\t\tend)\r\n\r\n\t\tit(\"should catch asynchronous errors\", function()\r\n\t\t\tlocal bindable = Instance.new(\"BindableEvent\")\r\n\t\t\tlocal promise = Promise.try(function()\r\n\t\t\t\tbindable.Event:Wait()\r\n\t\t\t\terror('errortext')\r\n\t\t\tend)\r\n\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Started)\r\n\t\t\tbindable:Fire()\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Rejected)\r\n\t\t\texpect(tostring(promise._values[1]):find(\"errortext\")).to.be.ok()\r\n\t\tend)\r\n\tend)\r\n\r\n\tdescribe(\"Promise:andThenReturn\", function()\r\n\t\tit(\"should return the given values\", function()\r\n\t\t\tlocal value1, value2\r\n\r\n\t\t\tPromise.resolve():andThenReturn(1, 2):andThen(function(one, two)\r\n\t\t\t\tvalue1 = one\r\n\t\t\t\tvalue2 = two\r\n\t\t\tend)\r\n\r\n\t\t\texpect(value1).to.equal(1)\r\n\t\t\texpect(value2).to.equal(2)\r\n\t\tend)\r\n\tend)\r\n\r\n\tdescribe(\"Promise:doneReturn\", function()\r\n\t\tit(\"should return the given values\", function()\r\n\t\t\tlocal value1, value2\r\n\r\n\t\t\tPromise.resolve():doneReturn(1, 2):andThen(function(one, two)\r\n\t\t\t\tvalue1 = one\r\n\t\t\t\tvalue2 = two\r\n\t\t\tend)\r\n\r\n\t\t\texpect(value1).to.equal(1)\r\n\t\t\texpect(value2).to.equal(2)\r\n\t\tend)\r\n\tend)\r\n\r\n\tdescribe(\"Promise:andThenCall\", function()\r\n\t\tit(\"should call the given function with arguments\", function()\r\n\t\t\tlocal value1, value2\r\n\t\t\tPromise.resolve():andThenCall(function(a, b)\r\n\t\t\t\tvalue1 = a\r\n\t\t\t\tvalue2 = b\r\n\t\t\tend, 3, 4)\r\n\r\n\t\t\texpect(value1).to.equal(3)\r\n\t\t\texpect(value2).to.equal(4)\r\n\t\tend)\r\n\tend)\r\n\r\n\tdescribe(\"Promise:doneCall\", function()\r\n\t\tit(\"should call the given function with arguments\", function()\r\n\t\t\tlocal value1, value2\r\n\t\t\tPromise.resolve():doneCall(function(a, b)\r\n\t\t\t\tvalue1 = a\r\n\t\t\t\tvalue2 = b\r\n\t\t\tend, 3, 4)\r\n\r\n\t\t\texpect(value1).to.equal(3)\r\n\t\t\texpect(value2).to.equal(4)\r\n\t\tend)\r\n\tend)\r\n\r\n\tdescribe(\"Promise:done\", function()\r\n\t\tit(\"should trigger on resolve or cancel\", function()\r\n\t\t\tlocal promise = Promise.new(function() end)\r\n\t\t\tlocal value\r\n\r\n\t\t\tlocal p = promise:done(function()\r\n\t\t\t\tvalue = true\r\n\t\t\tend)\r\n\r\n\t\t\texpect(value).to.never.be.ok()\r\n\t\t\tpromise:cancel()\r\n\t\t\texpect(p:getStatus()).to.equal(Promise.Status.Cancelled)\r\n\t\t\texpect(value).to.equal(true)\r\n\r\n\t\t\tlocal never, always\r\n\t\t\tPromise.reject():done(function()\r\n\t\t\t\tnever = true\r\n\t\t\tend):finally(function()\r\n\t\t\t\talways = true\r\n\t\t\tend)\r\n\r\n\t\t\texpect(never).to.never.be.ok()\r\n\t\t\texpect(always).to.be.ok()\r\n\t\tend)\r\n\tend)\r\n\r\n\tdescribe(\"Promise.some\", function()\r\n\t\tit(\"should resolve once the goal is reached\", function()\r\n\t\t\tlocal p = Promise.some({\r\n\t\t\t\tPromise.resolve(1),\r\n\t\t\t\tPromise.reject(),\r\n\t\t\t\tPromise.resolve(2)\r\n\t\t\t}, 2)\r\n\t\t\texpect(p:getStatus()).to.equal(Promise.Status.Resolved)\r\n\t\t\texpect(p._values[1][1]).to.equal(1)\r\n\t\t\texpect(p._values[1][2]).to.equal(2)\r\n\t\tend)\r\n\r\n\t\tit(\"should error if the goal can't be reached\", function()\r\n\t\t\texpect(Promise.some({\r\n\t\t\t\tPromise.resolve(),\r\n\t\t\t\tPromise.reject()\r\n\t\t\t}, 2):getStatus()).to.equal(Promise.Status.Rejected)\r\n\r\n\t\t\tlocal reject\r\n\t\t\tlocal p = Promise.some({\r\n\t\t\t\tPromise.resolve(),\r\n\t\t\t\tPromise.new(function(_, r) reject = r end)\r\n\t\t\t}, 2)\r\n\r\n\t\t\texpect(p:getStatus()).to.equal(Promise.Status.Started)\r\n\t\t\treject(\"foo\")\r\n\t\t\texpect(p:getStatus()).to.equal(Promise.Status.Rejected)\r\n\t\t\texpect(p._values[1]).to.equal(\"foo\")\r\n\t\tend)\r\n\r\n\t\tit(\"should cancel pending Promises once the goal is reached\", function()\r\n\t\t\tlocal resolve\r\n\t\t\tlocal pending1 = Promise.new(function() end)\r\n\t\t\tlocal pending2 = Promise.new(function(r) resolve = r end)\r\n\r\n\t\t\tlocal some = Promise.some({\r\n\t\t\t\tpending1,\r\n\t\t\t\tpending2,\r\n\t\t\t\tPromise.resolve()\r\n\t\t\t}, 2)\r\n\r\n\t\t\texpect(some:getStatus()).to.equal(Promise.Status.Started)\r\n\t\t\texpect(pending1:getStatus()).to.equal(Promise.Status.Started)\r\n\t\t\texpect(pending2:getStatus()).to.equal(Promise.Status.Started)\r\n\r\n\t\t\tresolve()\r\n\r\n\t\t\texpect(some:getStatus()).to.equal(Promise.Status.Resolved)\r\n\t\t\texpect(pending1:getStatus()).to.equal(Promise.Status.Cancelled)\r\n\t\t\texpect(pending2:getStatus()).to.equal(Promise.Status.Resolved)\r\n\t\tend)\r\n\r\n\t\tit(\"should error if passed a non-number\", function()\r\n\t\t\texpect(function()\r\n\t\t\t\tPromise.some({}, \"non-number\")\r\n\t\t\tend).to.throw()\r\n\t\tend)\r\n\r\n\t\tit(\"should return an empty array if amount is 0\", function()\r\n\t\t\tlocal p = Promise.some({\r\n\t\t\t\tPromise.resolve(2)\r\n\t\t\t}, 0)\r\n\r\n\t\t\texpect(p:getStatus()).to.equal(Promise.Status.Resolved)\r\n\t\t\texpect(#p._values[1]).to.equal(0)\r\n\t\tend)\r\n\r\n\t\tit(\"should not return extra values\", function()\r\n\t\t\tlocal p = Promise.some({\r\n\t\t\t\tPromise.resolve(1),\r\n\t\t\t\tPromise.resolve(2),\r\n\t\t\t\tPromise.resolve(3),\r\n\t\t\t\tPromise.resolve(4),\r\n\t\t\t}, 2)\r\n\r\n\t\t\texpect(p:getStatus()).to.equal(Promise.Status.Resolved)\r\n\t\t\texpect(#p._values[1]).to.equal(2)\r\n\t\t\texpect(p._values[1][1]).to.equal(1)\r\n\t\t\texpect(p._values[1][2]).to.equal(2)\r\n\t\tend)\r\n\r\n\t\tit(\"should cancel promises if it is cancelled\", function()\r\n\t\t\tlocal p = Promise.new(function() end)\r\n\t\t\tp:andThen(function() end)\r\n\r\n\t\t\tlocal promises = {\r\n\t\t\t\tPromise.new(function() end),\r\n\t\t\t\tPromise.new(function() end),\r\n\t\t\t\tp\r\n\t\t\t}\r\n\r\n\t\t\tPromise.some(promises, 3):cancel()\r\n\r\n\t\t\texpect(promises[1]:getStatus()).to.equal(Promise.Status.Cancelled)\r\n\t\t\texpect(promises[2]:getStatus()).to.equal(Promise.Status.Cancelled)\r\n\t\t\texpect(promises[3]:getStatus()).to.equal(Promise.Status.Started)\r\n\t\tend)\r\n\r\n\t\tdescribe(\"Promise.any\", function()\r\n\t\t\tit(\"should return the value directly\", function()\r\n\t\t\t\tlocal p = Promise.any({\r\n\t\t\t\t\tPromise.reject(),\r\n\t\t\t\t\tPromise.reject(),\r\n\t\t\t\t\tPromise.resolve(1)\r\n\t\t\t\t})\r\n\r\n\t\t\t\texpect(p:getStatus()).to.equal(Promise.Status.Resolved)\r\n\t\t\t\texpect(p._values[1]).to.equal(1)\r\n\t\t\tend)\r\n\r\n\t\t\tit(\"should error if all are rejected\", function()\r\n\t\t\t\texpect(Promise.any({\r\n\t\t\t\t\tPromise.reject(),\r\n\t\t\t\t\tPromise.reject(),\r\n\t\t\t\t\tPromise.reject(),\r\n\t\t\t\t}):getStatus()).to.equal(Promise.Status.Rejected)\r\n\t\t\tend)\r\n\t\tend)\r\n\tend)\r\n\r\n\tdescribe(\"Promise.allSettled\", function()\r\n\t\tit(\"should resolve with an array of PromiseStatuses\", function()\r\n\t\t\tlocal reject\r\n\t\t\tlocal p = Promise.allSettled({\r\n\t\t\t\tPromise.resolve(),\r\n\t\t\t\tPromise.reject(),\r\n\t\t\t\tPromise.resolve(),\r\n\t\t\t\tPromise.new(function(_, r) reject = r end)\r\n\t\t\t})\r\n\r\n\t\t\texpect(p:getStatus()).to.equal(Promise.Status.Started)\r\n\t\t\treject()\r\n\t\t\texpect(p:getStatus()).to.equal(Promise.Status.Resolved)\r\n\t\t\texpect(p._values[1][1]).to.equal(Promise.Status.Resolved)\r\n\t\t\texpect(p._values[1][2]).to.equal(Promise.Status.Rejected)\r\n\t\t\texpect(p._values[1][3]).to.equal(Promise.Status.Resolved)\r\n\t\t\texpect(p._values[1][4]).to.equal(Promise.Status.Rejected)\r\n\t\tend)\r\n\r\n\t\tit(\"should cancel promises if it is cancelled\", function()\r\n\t\t\tlocal p = Promise.new(function() end)\r\n\t\t\tp:andThen(function() end)\r\n\r\n\t\t\tlocal promises = {\r\n\t\t\t\tPromise.new(function() end),\r\n\t\t\t\tPromise.new(function() end),\r\n\t\t\t\tp\r\n\t\t\t}\r\n\r\n\t\t\tPromise.allSettled(promises):cancel()\r\n\r\n\t\t\texpect(promises[1]:getStatus()).to.equal(Promise.Status.Cancelled)\r\n\t\t\texpect(promises[2]:getStatus()).to.equal(Promise.Status.Cancelled)\r\n\t\t\texpect(promises[3]:getStatus()).to.equal(Promise.Status.Started)\r\n\t\tend)\r\n\tend)\r\n\r\n\tdescribe(\"Promise:await\", function()\r\n\t\tit(\"should return the correct values\", function()\r\n\t\t\tlocal promise = Promise.resolve(5, 6, nil, 7)\r\n\r\n\t\t\tlocal a, b, c, d, e = promise:await()\r\n\r\n\t\t\texpect(a).to.equal(true)\r\n\t\t\texpect(b).to.equal(5)\r\n\t\t\texpect(c).to.equal(6)\r\n\t\t\texpect(d).to.equal(nil)\r\n\t\t\texpect(e).to.equal(7)\r\n\t\tend)\r\n\tend)\r\n\r\n\tdescribe(\"Promise:expect\", function()\r\n\t\tit(\"should throw the correct values\", function()\r\n\t\t\tlocal rejectionValue = {}\r\n\t\t\tlocal promise = Promise.reject(rejectionValue)\r\n\r\n\t\t\tlocal success, value = pcall(function()\r\n\t\t\t\tpromise:expect()\r\n\t\t\tend)\r\n\r\n\t\t\texpect(success).to.equal(false)\r\n\t\t\texpect(value).to.equal(rejectionValue)\r\n\t\tend)\r\n\tend)\r\n\r\n\tdescribe(\"Promise:now\", function()\r\n\t\tit(\"should resolve if the Promise is resolved\", function()\r\n\t\t\tlocal success, value = Promise.resolve(\"foo\"):now():_unwrap()\r\n\r\n\t\t\texpect(success).to.equal(true)\r\n\t\t\texpect(value).to.equal(\"foo\")\r\n\t\tend)\r\n\r\n\t\tit(\"should reject if the Promise is not resolved\", function()\r\n\t\t\tlocal success, value = Promise.new(function() end):now():_unwrap()\r\n\r\n\t\t\texpect(success).to.equal(false)\r\n\t\t\texpect(Promise.Error.isKind(value, \"NotResolvedInTime\")).to.equal(true)\r\n\t\tend)\r\n\r\n\t\tit(\"should reject with a custom rejection value\", function()\r\n\t\t\tlocal success, value = Promise.new(function() end):now(\"foo\"):_unwrap()\r\n\r\n\t\t\texpect(success).to.equal(false)\r\n\t\t\texpect(value).to.equal(\"foo\")\r\n\t\tend)\r\n\tend)\r\n\r\n\tdescribe(\"Promise.each\", function()\r\n\t\tit(\"should iterate\", function()\r\n\t\t\tlocal ok, result = Promise.each({\r\n\t\t\t\t\"foo\", \"bar\", \"baz\", \"qux\"\r\n\t\t\t}, function(...)\r\n\t\t\t\treturn {...}\r\n\t\t\tend):_unwrap()\r\n\r\n\t\t\texpect(ok).to.equal(true)\r\n\t\t\texpect(result[1][1]).to.equal(\"foo\")\r\n\t\t\texpect(result[1][2]).to.equal(1)\r\n\t\t\texpect(result[2][1]).to.equal(\"bar\")\r\n\t\t\texpect(result[2][2]).to.equal(2)\r\n\t\t\texpect(result[3][1]).to.equal(\"baz\")\r\n\t\t\texpect(result[3][2]).to.equal(3)\r\n\t\t\texpect(result[4][1]).to.equal(\"qux\")\r\n\t\t\texpect(result[4][2]).to.equal(4)\r\n\t\tend)\r\n\r\n\t\tit(\"should iterate serially\", function()\r\n\t\t\tlocal resolves = {}\r\n\t\t\tlocal callCounts = {}\r\n\r\n\t\t\tlocal promise = Promise.each({\r\n\t\t\t\t\"foo\", \"bar\", \"baz\"\r\n\t\t\t}, function(value, index)\r\n\t\t\t\tcallCounts[index] = (callCounts[index] or 0) + 1\r\n\r\n\t\t\t\treturn Promise.new(function(resolve)\r\n\t\t\t\t\ttable.insert(resolves, function()\r\n\t\t\t\t\t\tresolve(value:upper())\r\n\t\t\t\t\tend)\r\n\t\t\t\tend)\r\n\t\t\tend)\r\n\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Started)\r\n\t\t\texpect(#resolves).to.equal(1)\r\n\t\t\texpect(callCounts[1]).to.equal(1)\r\n\t\t\texpect(callCounts[2]).to.never.be.ok()\r\n\r\n\t\t\ttable.remove(resolves, 1)()\r\n\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Started)\r\n\t\t\texpect(#resolves).to.equal(1)\r\n\t\t\texpect(callCounts[1]).to.equal(1)\r\n\t\t\texpect(callCounts[2]).to.equal(1)\r\n\t\t\texpect(callCounts[3]).to.never.be.ok()\r\n\r\n\t\t\ttable.remove(resolves, 1)()\r\n\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Started)\r\n\t\t\texpect(callCounts[1]).to.equal(1)\r\n\t\t\texpect(callCounts[2]).to.equal(1)\r\n\t\t\texpect(callCounts[3]).to.equal(1)\r\n\r\n\t\t\ttable.remove(resolves, 1)()\r\n\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Resolved)\r\n\t\t\texpect(type(promise._values[1])).to.equal(\"table\")\r\n\t\t\texpect(type(promise._values[2])).to.equal(\"nil\")\r\n\r\n\t\t\tlocal result = promise._values[1]\r\n\r\n\t\t\texpect(result[1]).to.equal(\"FOO\")\r\n\t\t\texpect(result[2]).to.equal(\"BAR\")\r\n\t\t\texpect(result[3]).to.equal(\"BAZ\")\r\n\t\tend)\r\n\r\n\t\tit(\"should reject with the value if the predicate promise rejects\", function()\r\n\t\t\tlocal promise = Promise.each({1, 2, 3}, function()\r\n\t\t\t\treturn Promise.reject(\"foobar\")\r\n\t\t\tend)\r\n\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Rejected)\r\n\t\t\texpect(promise._values[1]).to.equal(\"foobar\")\r\n\t\tend)\r\n\r\n\t\tit(\"should allow Promises to be in the list and wait when it gets to them\", function()\r\n\t\t\tlocal innerResolve\r\n\t\t\tlocal innerPromise = Promise.new(function(resolve)\r\n\t\t\t\tinnerResolve = resolve\r\n\t\t\tend)\r\n\r\n\t\t\tlocal promise = Promise.each({\r\n\t\t\t\tinnerPromise\r\n\t\t\t}, function(value)\r\n\t\t\t\treturn value * 2\r\n\t\t\tend)\r\n\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Started)\r\n\r\n\t\t\tinnerResolve(2)\r\n\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Resolved)\r\n\t\t\texpect(promise._values[1][1]).to.equal(4)\r\n\t\tend)\r\n\r\n\t\tit(\"should reject with the value if a Promise from the list rejects\", function()\r\n\t\t\tlocal called = false\r\n\t\t\tlocal promise = Promise.each({1, 2, Promise.reject(\"foobar\")}, function(value)\r\n\t\t\t\tcalled = true\r\n\t\t\t\treturn \"never\"\r\n\t\t\tend)\r\n\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Rejected)\r\n\t\t\texpect(promise._values[1]).to.equal(\"foobar\")\r\n\t\t\texpect(called).to.equal(false)\r\n\t\tend)\r\n\r\n\t\tit(\"should reject immediately if there's a cancelled Promise in the list initially\", function()\r\n\t\t\tlocal cancelled = Promise.new(function() end)\r\n\t\t\tcancelled:cancel()\r\n\r\n\t\t\tlocal called = false\r\n\t\t\tlocal promise = Promise.each({1, 2, cancelled}, function()\r\n\t\t\t\tcalled = true\r\n\t\t\tend)\r\n\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Rejected)\r\n\t\t\texpect(called).to.equal(false)\r\n\t\t\texpect(promise._values[1].kind).to.equal(Promise.Error.Kind.AlreadyCancelled)\r\n\t\tend)\r\n\r\n\t\tit(\"should stop iteration if Promise.each is cancelled\", function()\r\n\t\t\tlocal callCounts = {}\r\n\r\n\t\t\tlocal promise = Promise.each({\r\n\t\t\t\t\"foo\", \"bar\", \"baz\"\r\n\t\t\t}, function(value, index)\r\n\t\t\t\tcallCounts[index] = (callCounts[index] or 0) + 1\r\n\r\n\t\t\t\treturn Promise.new(function()\r\n\r\n\t\t\t\tend)\r\n\t\t\tend)\r\n\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Started)\r\n\t\t\texpect(callCounts[1]).to.equal(1)\r\n\t\t\texpect(callCounts[2]).to.never.be.ok()\r\n\r\n\t\t\tpromise:cancel()\r\n\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Cancelled)\r\n\t\t\texpect(callCounts[1]).to.equal(1)\r\n\t\t\texpect(callCounts[2]).to.never.be.ok()\r\n\t\tend)\r\n\r\n\t\tit(\"should cancel the Promise returned from the predicate if Promise.each is cancelled\", function()\r\n\t\t\tlocal innerPromise\r\n\r\n\t\t\tlocal promise = Promise.each({\r\n\t\t\t\t\"foo\", \"bar\", \"baz\"\r\n\t\t\t}, function(value, index)\r\n\t\t\t\tinnerPromise = Promise.new(function()\r\n\t\t\t\tend)\r\n\t\t\t\treturn innerPromise\r\n\t\t\tend)\r\n\r\n\t\t\tpromise:cancel()\r\n\r\n\t\t\texpect(innerPromise:getStatus()).to.equal(Promise.Status.Cancelled)\r\n\t\tend)\r\n\r\n\t\tit(\"should cancel Promises in the list if Promise.each is cancelled\", function()\r\n\t\t\tlocal innerPromise = Promise.new(function() end)\r\n\r\n\t\t\tlocal promise = Promise.each({innerPromise}, function() end)\r\n\r\n\t\t\tpromise:cancel()\r\n\r\n\t\t\texpect(innerPromise:getStatus()).to.equal(Promise.Status.Cancelled)\r\n\t\tend)\r\n\tend)\r\n\r\n\tdescribe(\"Promise.retry\", function()\r\n\t\tit(\"should retry N times\", function()\r\n\t\t\tlocal counter = 0\r\n\r\n\t\t\tlocal promise = Promise.retry(function(parameter)\r\n\t\t\t\texpect(parameter).to.equal(\"foo\")\r\n\r\n\t\t\t\tcounter = counter + 1\r\n\r\n\t\t\t\tif counter == 5 then\r\n\t\t\t\t\treturn Promise.resolve(\"ok\")\r\n\t\t\t\tend\r\n\r\n\t\t\t\treturn Promise.reject(\"fail\")\r\n\t\t\tend, 5, \"foo\")\r\n\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Resolved)\r\n\t\t\texpect(promise._values[1]).to.equal(\"ok\")\r\n\t\tend)\r\n\r\n\t\tit(\"should reject if threshold is exceeded\", function()\r\n\t\t\tlocal promise = Promise.retry(function()\r\n\t\t\t\treturn Promise.reject(\"fail\")\r\n\t\t\tend, 5)\r\n\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Rejected)\r\n\t\t\texpect(promise._values[1]).to.equal(\"fail\")\r\n\t\tend)\r\n\tend)\r\n\r\n\tdescribe(\"Promise.fromEvent\", function()\r\n\t\tit(\"should convert a Promise into an event\", function()\r\n\t\t\tlocal event = Instance.new(\"BindableEvent\")\r\n\r\n\t\t\tlocal promise = Promise.fromEvent(event.Event)\r\n\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Started)\r\n\r\n\t\t\tevent:Fire(\"foo\")\r\n\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Resolved)\r\n\t\t\texpect(promise._values[1]).to.equal(\"foo\")\r\n\t\tend)\r\n\r\n\t\tit(\"should convert a Promise into an event with the predicate\", function()\r\n\t\t\tlocal event = Instance.new(\"BindableEvent\")\r\n\r\n\t\t\tlocal promise = Promise.fromEvent(event.Event, function(param)\r\n\t\t\t\treturn param == \"foo\"\r\n\t\t\tend)\r\n\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Started)\r\n\r\n\t\t\tevent:Fire(\"bar\")\r\n\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Started)\r\n\r\n\t\t\tevent:Fire(\"foo\")\r\n\r\n\t\t\texpect(promise:getStatus()).to.equal(Promise.Status.Resolved)\r\n\t\t\texpect(promise._values[1]).to.equal(\"foo\")\r\n\t\tend)\r\n\tend)\r\n\r\n\tdescribe(\"Promise.is\", function()\r\n\t\tit(\"should work with current version\", function()\r\n\t\t\tlocal promise = Promise.resolve(1)\r\n\r\n\t\t\texpect(Promise.is(promise)).to.equal(true)\r\n\t\tend)\r\n\r\n\t\tit(\"should work with any object with an andThen\", function()\r\n\t\t\tlocal obj = {\r\n\t\t\t\tandThen = function()\r\n\t\t\t\t\treturn 1\r\n\t\t\t\tend\r\n\t\t\t}\r\n\r\n\t\t\texpect(Promise.is(obj)).to.equal(true)\r\n\t\tend)\r\n\r\n\t\tit(\"should work with older promises\", function()\r\n\t\t\tlocal OldPromise = {}\r\n\t\t\tOldPromise.prototype = {}\r\n\t\t\tOldPromise.__index = OldPromise.prototype\r\n\r\n\t\t\tfunction OldPromise.prototype:andThen()\r\n\r\n\t\t\tend\r\n\r\n\t\t\tlocal oldPromise = setmetatable({}, OldPromise)\r\n\r\n\t\t\texpect(Promise.is(oldPromise)).to.equal(true)\r\n\t\tend)\r\n\tend)\r\nend\r\n"}},"Children":[],"Metadata":{"ignoreUnknownInstances":false}},"8d7217c7f2aaf98a45b764cd6f5e70a3":{"Id":"8d7217c7f2aaf98a45b764cd6f5e70a3","Parent":"ee222f38fa8be78c47f18fd875ac7854","Name":"Promise","ClassName":"ModuleScript","Properties":{"Source":{"String":"return require(script.Parent._Index[\"evaera_promise@3.1.0\"][\"promise\"])\n"}},"Children":[],"Metadata":{"ignoreUnknownInstances":false}},"5d73467a1d588843ea200ceeebce3eb5":{"Id":"5d73467a1d588843ea200ceeebce3eb5","Parent":"372383b65caa3b15b65ef42feec874b8","Name":"Workspace","ClassName":"Workspace","Properties":{"FilteringEnabled":{"Bool":true}},"Children":["1a31bb8458eefe0db2d00eab15f6b14f"],"Metadata":{"ignoreUnknownInstances":true}},"3b4376cbee89fe33103b0e674597c0ea":{"Id":"3b4376cbee89fe33103b0e674597c0ea","Parent":"aa5772ae3a91cb8b93b724d7c5a15190","Name":"promiseAwaitValue","ClassName":"ModuleScript","Properties":{"Source":{"String":"local ReplicatedStorage: ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal Packages: Folder = ReplicatedStorage:WaitForChild(\"Packages\") :: Folder\nlocal Promise = require(Packages:WaitForChild(\"Promise\"))\n\nlocal function promiseAwaitForValue(value: string, list: { [string]: any }): any\n\tlocal conn: RBXScriptConnection\n\tlocal promise = Promise.new(function(resolve, _, onCancel)\n\t\tconn = RunService.Heartbeat:Connect(function()\n\t\t\tlocal _context = list[value]\n\t\t\tif _context then\n\t\t\t\tresolve(_context)\n\t\t\tend\n\t\tend)\n\t\tonCancel(function()\n\t\t\tconn:Disconnect()\n\t\tend)\n\tend):finally(function()\n\t\tconn:Disconnect()\n\tend)\n\n\treturn promise\nend\n\nreturn promiseAwaitForValue\n"}},"Children":[],"Metadata":{"ignoreUnknownInstances":false}},"b006666de7a034699290c8f7a42446bf":{"Id":"b006666de7a034699290c8f7a42446bf","Parent":"e412d57eace8911b86fabef6e8521d77","Name":"Subscription","ClassName":"ModuleScript","Properties":{"Source":{"String":"local types = require(script.Parent.Types)\r\nlocal t = require(script.Parent.Parent.t)\r\n\r\nexport type ISubscription = types.ISubscription\r\n\r\nlocal Subscription: ISubscription\r\nSubscription.__index = Subscription\r\n\r\nfunction Subscription.new(context: string, action: string, callback: () -> ()?): ISubscription\r\n\r\n\tlocal self: ISubscription\r\n\tself.Context = context,\r\n\tself.Action = action,\r\n\tself.Callback = callback\r\n\r\n\treturn setmetatable(self, Subscription) :: ISubscription\r\nend\r\n\r\nfunction Subscription.is(obj: any): boolean\r\n\treturn types.isSubscription(obj)\r\nend\r\n\r\nfunction Subscription:Subscribe(callback: () -> nil): ISubscription\r\n\treturn self\r\nend\r\n\r\nreturn Subscription"}},"Children":[],"Metadata":{"ignoreUnknownInstances":false}},"c7c89a6fc94431da37e9bff85b81ab47":{"Id":"c7c89a6fc94431da37e9bff85b81ab47","Parent":"d539d2b3547c9166dae5ffd367a37cb3","Name":"IWormhole","ClassName":"ModuleScript","Properties":{"Source":{"String":"local t = require(script.Parent.Parent.Parent.t)\r\n\r\nlocal ContextBlock: (obj: any) -> boolean = require(script.Parent.ContextBlock)\r\nlocal ISubscription: (obj: any) -> boolean = require(script.Parent.ISubscription)\r\nlocal IContext: (obj: any) -> boolean = require(script.Parent.IContext)\r\n\r\ntype ContextBlock = ContextBlock.ContextBlock\r\ntype ISubscription = ISubscription.ISubscription\r\ntype IContext = IContext.IContext\r\n\r\nlocal isWormhole: (obj: any) -> boolean = t.interface({\r\n\t_Storage = t.instanceIsA(\"Folder\"),\r\n\t_Contexts = t.map(t.string, t.any)\r\n})\r\n\r\nexport type IWormhole = {\r\n\t_Storage: Folder,\r\n\t_Contexts: {[string]: ContextBlock},\r\n\r\n\t__index: IWormhole,\r\n\r\n\tnew: (wormhole: IWormhole) -> IWormhole,\r\n\tis: (obj: any) -> boolean,\r\n\r\n\tawaitContext: (wormhole: IWormhole, context: string, timeout: number?) -> ContextBlock,\r\n\taddContext: (wormhole: IWormhole, context: string) -> ContextBlock,\r\n\tmakeSubscription: (wormhole: IWormhole, context: string, action: string) ->ISubscription,\r\n\tdoSubscribe: (wormhole: IWormhole, subscription: ISubscription, callback: () -> nil?) -> ()\r\n}\r\n\r\nreturn function(obj)\r\n\treturn isWormhole(obj) :: boolean\r\nend"}},"Children":[],"Metadata":{"ignoreUnknownInstances":false}},"aa5772ae3a91cb8b93b724d7c5a15190":{"Id":"aa5772ae3a91cb8b93b724d7c5a15190","Parent":"e412d57eace8911b86fabef6e8521d77","Name":"Promises","ClassName":"Folder","Properties":{},"Children":["3b4376cbee89fe33103b0e674597c0ea"],"Metadata":{"ignoreUnknownInstances":false}},"9c8522e307357cb958492ee98fd93042":{"Id":"9c8522e307357cb958492ee98fd93042","Parent":"d539d2b3547c9166dae5ffd367a37cb3","Name":"IPackage","ClassName":"ModuleScript","Properties":{"Source":{"String":"local t = require(script.Parent.Parent.Parent.t)\n\nlocal function isDateTime(value: any): (boolean, string?)\n\tlocal valueType = typeof(value)\n\tif valueType == \"DateTime\" then\n\t\treturn true\n\telse\n\t\treturn false, string.format(\"DateTime expected, got %s\", valueType)\n\tend\nend\n\nlocal isPackage: (obj: any) -> boolean = t.interface({\n\tContext = t.string,\n\tAction = t.string,\n\tDateTime = isDateTime,\n\tPayload = t.map(t.string, t.any),\n})\n\nexport type IPackage = {\n\tContext: string,\n\tAction: string,\n\tTimestamp: DateTime,\n\tPayload: { [string]: any },\n}\n\nreturn function(obj: any): boolean\n\treturn isPackage(obj)\nend\n"}},"Children":[],"Metadata":{"ignoreUnknownInstances":false}},"2d5696ee5bdf4c8a0a542bf58f63b738":{"Id":"2d5696ee5bdf4c8a0a542bf58f63b738","Parent":"e412d57eace8911b86fabef6e8521d77","Name":"Context","ClassName":"ModuleScript","Properties":{"Source":{"String":"local types = require(script.Parent.Types)\nlocal t = require(script.Parent.Parent.t)\n\nexport type IContext = types.IContext\n\ntype IWormhole = types.IWormhole\n\nlocal Context: IContext\nContext.__index = Context\n\nfunction Context.new(context: string, wormhole: IWormhole): IContext\n\tlocal check = t.strict(t.string)\n\tcheck(context)\n\n\tlocal self: IContext\n\tself.Name = context\n\tself.Subscriptions = {}\n\n\treturn setmetatable(self, Context) :: IContext\nend\n\nfunction Context.is(obj: any): boolean\n\treturn types.isContext(obj)\nend\n\nfunction Context:Publish(action: string, data: any) end\n\nfunction Context:Subscribe(action: string, callback: () -> ()) end\n\nfunction Context:Destroy() end\n\nreturn Context\n"}},"Children":[],"Metadata":{"ignoreUnknownInstances":false}},"bc7710f6aad3249798ac01ac70c608b3":{"Id":"bc7710f6aad3249798ac01ac70c608b3","Parent":"372383b65caa3b15b65ef42feec874b8","Name":"Lighting","ClassName":"Lighting","Properties":{"Brightness":{"Float32":2.0},"Ambient":{"Color3":[0.0,0.0,0.0]},"GlobalShadows":{"Bool":true},"Outlines":{"Bool":false},"Technology":{"Enum":1}},"Children":[],"Metadata":{"ignoreUnknownInstances":true}},"d22adc3a9bd7195dae4e3c4ea2612c09":{"Id":"d22adc3a9bd7195dae4e3c4ea2612c09","Parent":"c39e26776de082e6222fc839fa8b1b48","Name":"init.spec","ClassName":"ModuleScript","Properties":{"Source":{"String":"return function()\r\n\tlocal t = require(script.Parent)\r\n\r\n\tit(\"should support basic types\", function()\r\n\t\tassert(t.any(\"\"))\r\n\t\tassert(t.boolean(true))\r\n\t\tassert(t.none(nil))\r\n\t\tassert(t.number(1))\r\n\t\tassert(t.string(\"foo\"))\r\n\t\tassert(t.table({}))\r\n\r\n\t\tassert(not (t.any(nil)))\r\n\t\tassert(not (t.boolean(\"true\")))\r\n\t\tassert(not (t.none(1)))\r\n\t\tassert(not (t.number(true)))\r\n\t\tassert(not (t.string(true)))\r\n\t\tassert(not (t.table(82)))\r\n\tend)\r\n\r\n\tit(\"should support special number types\", function()\r\n\t\tlocal maxTen = t.numberMax(10)\r\n\t\tlocal minTwo = t.numberMin(2)\r\n\t\tlocal maxTenEx = t.numberMaxExclusive(10)\r\n\t\tlocal minTwoEx = t.numberMinExclusive(2)\r\n\t\tlocal constrainedEightToEleven = t.numberConstrained(8, 11)\r\n\t\tlocal constrainedEightToElevenEx = t.numberConstrainedExclusive(8, 11)\r\n\r\n\t\tassert(maxTen(5))\r\n\t\tassert(maxTen(10))\r\n\t\tassert(not (maxTen(11)))\r\n\t\tassert(not (maxTen()))\r\n\r\n\t\tassert(minTwo(5))\r\n\t\tassert(minTwo(2))\r\n\t\tassert(not (minTwo(1)))\r\n\t\tassert(not (minTwo()))\r\n\r\n\t\tassert(maxTenEx(5))\r\n\t\tassert(maxTenEx(9))\r\n\t\tassert(not (maxTenEx(10)))\r\n\t\tassert(not (maxTenEx()))\r\n\r\n\t\tassert(minTwoEx(5))\r\n\t\tassert(minTwoEx(3))\r\n\t\tassert(not (minTwoEx(2)))\r\n\t\tassert(not (minTwoEx()))\r\n\r\n\t\tassert(not (constrainedEightToEleven(7)))\r\n\t\tassert(constrainedEightToEleven(8))\r\n\t\tassert(constrainedEightToEleven(9))\r\n\t\tassert(constrainedEightToEleven(11))\r\n\t\tassert(not (constrainedEightToEleven(12)))\r\n\t\tassert(not (constrainedEightToEleven()))\r\n\r\n\t\tassert(not (constrainedEightToElevenEx(7)))\r\n\t\tassert(not (constrainedEightToElevenEx(8)))\r\n\t\tassert(constrainedEightToElevenEx(9))\r\n\t\tassert(not (constrainedEightToElevenEx(11)))\r\n\t\tassert(not (constrainedEightToElevenEx(12)))\r\n\t\tassert(not (constrainedEightToElevenEx()))\r\n\tend)\r\n\r\n\tit(\"should support optional types\", function()\r\n\t\tlocal check = t.optional(t.string)\r\n\t\tassert(check(\"\"))\r\n\t\tassert(check())\r\n\t\tassert(not (check(1)))\r\n\tend)\r\n\r\n\tit(\"should support tuple types\", function()\r\n\t\tlocal myTupleCheck = t.tuple(t.number, t.string, t.optional(t.number))\r\n\t\tassert(myTupleCheck(1, \"2\", 3))\r\n\t\tassert(myTupleCheck(1, \"2\"))\r\n\t\tassert(not (myTupleCheck(1, \"2\", \"3\")))\r\n\tend)\r\n\r\n\tit(\"should support union types\", function()\r\n\t\tlocal numberOrString = t.union(t.number, t.string)\r\n\t\tassert(numberOrString(1))\r\n\t\tassert(numberOrString(\"1\"))\r\n\t\tassert(not (numberOrString(nil)))\r\n\tend)\r\n\r\n\tit(\"should support literal types\", function()\r\n\t\tlocal checkSingle = t.literal(\"foo\")\r\n\t\tlocal checkUnion = t.union(t.literal(\"foo\"), t.literal(\"bar\"), t.literal(\"oof\"))\r\n\r\n\t\tassert(checkSingle(\"foo\"))\r\n\t\tassert(checkUnion(\"foo\"))\r\n\t\tassert(checkUnion(\"bar\"))\r\n\t\tassert(checkUnion(\"oof\"))\r\n\r\n\t\tassert(not (checkSingle(\"FOO\")))\r\n\t\tassert(not (checkUnion(\"FOO\")))\r\n\t\tassert(not (checkUnion(\"BAR\")))\r\n\t\tassert(not (checkUnion(\"OOF\")))\r\n\tend)\r\n\r\n\tit(\"should support multiple literal types\", function()\r\n\t\tlocal checkSingle = t.literal(\"foo\")\r\n\t\tlocal checkUnion = t.literal(\"foo\", \"bar\", \"oof\")\r\n\r\n\t\tassert(checkSingle(\"foo\"))\r\n\t\tassert(checkUnion(\"foo\"))\r\n\t\tassert(checkUnion(\"bar\"))\r\n\t\tassert(checkUnion(\"oof\"))\r\n\r\n\t\tassert(not (checkSingle(\"FOO\")))\r\n\t\tassert(not (checkUnion(\"FOO\")))\r\n\t\tassert(not (checkUnion(\"BAR\")))\r\n\t\tassert(not (checkUnion(\"OOF\")))\r\n\tend)\r\n\r\n\tit(\"should support intersection types\", function()\r\n\t\tlocal integerMax5000 = t.intersection(t.integer, t.numberMax(5000))\r\n\t\tassert(integerMax5000(1))\r\n\t\tassert(not (integerMax5000(5001)))\r\n\t\tassert(not (integerMax5000(1.1)))\r\n\t\tassert(not (integerMax5000(\"1\")))\r\n\tend)\r\n\r\n\tdescribe(\"array\", function()\r\n\t\tit(\"should support array types\", function()\r\n\t\t\tlocal stringArray = t.array(t.string)\r\n\t\t\tlocal anyArray = t.array(t.any)\r\n\t\t\tlocal stringValues = t.values(t.string)\r\n\t\t\tassert(not (anyArray(\"foo\")))\r\n\t\t\tassert(anyArray({1, \"2\", 3}))\r\n\t\t\tassert(not (stringArray({1, \"2\", 3})))\r\n\t\t\tassert(not (stringArray()))\r\n\t\t\tassert(not (stringValues()))\r\n\t\t\tassert(anyArray({\"1\", \"2\", \"3\"}, t.string))\r\n\t\t\tassert(not (anyArray({\r\n\t\t\t\tfoo = \"bar\"\r\n\t\t\t})))\r\n\t\t\tassert(not (anyArray({\r\n\t\t\t\t[1] = \"non\",\r\n\t\t\t\t[5] = \"sequential\"\r\n\t\t\t})))\r\n\t\tend)\r\n\r\n\t\tit(\"should not be fooled by sparse arrays\", function()\r\n\t\t\tlocal anyArray = t.array(t.any)\r\n\r\n\t\t\tassert(not (anyArray({\r\n\t\t\t\t[1] = 1,\r\n\t\t\t\t[2] = 2,\r\n\t\t\t\t[4] = 4,\r\n\t\t\t})))\r\n\t\tend)\r\n\tend)\r\n\r\n\tit(\"should support map types\", function()\r\n\t\tlocal stringNumberMap = t.map(t.string, t.number)\r\n\t\tassert(stringNumberMap({}))\r\n\t\tassert(stringNumberMap({a = 1}))\r\n\t\tassert(not (stringNumberMap({[1] = \"a\"})))\r\n\t\tassert(not (stringNumberMap({a = \"a\"})))\r\n\t\tassert(not (stringNumberMap()))\r\n\tend)\r\n\r\n\tit(\"should support set types\", function()\r\n\t\tlocal stringSet = t.set(t.string)\r\n\t\tassert(stringSet({}))\r\n\t\tassert(stringSet({a = true}))\r\n\t\tassert(not (stringSet({[1] = \"a\"})))\r\n\t\tassert(not (stringSet({a = \"a\"})))\r\n\t\tassert(not (stringSet({a = false})))\r\n\t\tassert(not (stringSet()))\r\n\tend)\r\n\r\n\tit(\"should support interface types\", function()\r\n\t\tlocal IVector3 = t.interface({\r\n\t\t\tx = t.number,\r\n\t\t\ty = t.number,\r\n\t\t\tz = t.number,\r\n\t\t})\r\n\r\n\t\tassert(IVector3({\r\n\t\t\tw = 0,\r\n\t\t\tx = 1,\r\n\t\t\ty = 2,\r\n\t\t\tz = 3,\r\n\t\t}))\r\n\r\n\t\tassert(not (IVector3({\r\n\t\t\tw = 0,\r\n\t\t\tx = 1,\r\n\t\t\ty = 2,\r\n\t\t})))\r\n\tend)\r\n\r\n\tit(\"should support strict interface types\", function()\r\n\t\tlocal IVector3 = t.strictInterface({\r\n\t\t\tx = t.number,\r\n\t\t\ty = t.number,\r\n\t\t\tz = t.number,\r\n\t\t})\r\n\r\n\t\tassert(not (IVector3(0)))\r\n\r\n\t\tassert(not (IVector3({\r\n\t\t\tw = 0,\r\n\t\t\tx = 1,\r\n\t\t\ty = 2,\r\n\t\t\tz = 3,\r\n\t\t})))\r\n\r\n\t\tassert(not (IVector3({\r\n\t\t\tw = 0,\r\n\t\t\tx = 1,\r\n\t\t\ty = 2,\r\n\t\t})))\r\n\r\n\t\tassert(IVector3({\r\n\t\t\tx = 1,\r\n\t\t\ty = 2,\r\n\t\t\tz = 3,\r\n\t\t}))\r\n\tend)\r\n\r\n\tit(\"should support deep interface types\", function()\r\n\t\tlocal IPlayer = t.interface({\r\n\t\t\tname = t.string,\r\n\t\t\tinventory = t.interface({\r\n\t\t\t\tsize = t.number\r\n\t\t\t})\r\n\t\t})\r\n\r\n\t\tassert(IPlayer({\r\n\t\t\tname = \"TestPlayer\",\r\n\t\t\tinventory = {\r\n\t\t\t\tsize = 1\r\n\t\t\t}\r\n\t\t}))\r\n\r\n\t\tassert(not (IPlayer({\r\n\t\t\tinventory = {\r\n\t\t\t\tsize = 1\r\n\t\t\t}\r\n\t\t})))\r\n\r\n\t\tassert(not (IPlayer({\r\n\t\t\tname = \"TestPlayer\",\r\n\t\t\tinventory = {\r\n\t\t\t}\r\n\t\t})))\r\n\r\n\t\tassert(not (IPlayer({\r\n\t\t\tname = \"TestPlayer\",\r\n\t\t})))\r\n\tend)\r\n\r\n\tit(\"should support deep optional interface types\", function()\r\n\t\tlocal IPlayer = t.interface({\r\n\t\t\tname = t.string,\r\n\t\t\tinventory = t.optional(t.interface({\r\n\t\t\t\tsize = t.number\r\n\t\t\t}))\r\n\t\t})\r\n\r\n\t\tassert(IPlayer({\r\n\t\t\tname = \"TestPlayer\"\r\n\t\t}))\r\n\r\n\t\tassert(not (IPlayer({\r\n\t\t\tname = \"TestPlayer\",\r\n\t\t\tinventory = {\r\n\t\t\t}\r\n\t\t})))\r\n\r\n\t\tassert(IPlayer({\r\n\t\t\tname = \"TestPlayer\",\r\n\t\t\tinventory = {\r\n\t\t\t\tsize = 1\r\n\t\t\t}\r\n\t\t}))\r\n\tend)\r\n\r\n\tit(\"should support Roblox Instance types\", function()\r\n\t\tlocal stringValueCheck = t.instanceOf(\"StringValue\")\r\n\t\tlocal stringValue = Instance.new(\"StringValue\")\r\n\t\tlocal boolValue = Instance.new(\"BoolValue\")\r\n\r\n\t\tassert(stringValueCheck(stringValue))\r\n\t\tassert(not (stringValueCheck(boolValue)))\r\n\t\tassert(not (stringValueCheck()))\r\n\tend)\r\n\r\n\tit(\"should support Roblox Instance types inheritance\", function()\r\n\t\tlocal guiObjectCheck = t.instanceIsA(\"GuiObject\")\r\n\t\tlocal frame = Instance.new(\"Frame\")\r\n\t\tlocal textLabel = Instance.new(\"TextLabel\")\r\n\t\tlocal stringValue = Instance.new(\"StringValue\")\r\n\r\n\t\tassert(guiObjectCheck(frame))\r\n\t\tassert(guiObjectCheck(textLabel))\r\n\t\tassert(not (guiObjectCheck(stringValue)))\r\n\t\tassert(not (guiObjectCheck()))\r\n\tend)\r\n\r\n\tit(\"should support Roblox Enum types\", function()\r\n\t\tlocal sortOrderEnumCheck = t.enum(Enum.SortOrder)\r\n\t\tassert(t.Enum(Enum.SortOrder))\r\n\t\tassert(not (t.Enum(\"Enum.SortOrder\")))\r\n\r\n\t\tassert(t.EnumItem(Enum.SortOrder.Name))\r\n\t\tassert(not (t.EnumItem(\"Enum.SortOrder.Name\")))\r\n\r\n\t\tassert(sortOrderEnumCheck(Enum.SortOrder.Name))\r\n\t\tassert(sortOrderEnumCheck(Enum.SortOrder.Custom))\r\n\t\tassert(not (sortOrderEnumCheck(Enum.EasingStyle.Linear)))\r\n\t\tassert(not (sortOrderEnumCheck()))\r\n\tend)\r\n\r\n\tit(\"should support Roblox RBXScriptSignal\", function()\r\n\t\tassert(t.RBXScriptSignal(game.ChildAdded))\r\n\t\tassert(not (t.RBXScriptSignal(nil)))\r\n\t\tassert(not (t.RBXScriptSignal(Vector3.new())))\r\n\tend)\r\n\r\n\t-- TODO: Add this back when Lemur supports it\r\n\t-- it(\"should support Roblox RBXScriptConnection\", function()\r\n\t-- \tlocal conn = game.ChildAdded:Connect(function() end)\r\n\t-- \tassert(t.RBXScriptConnection(conn))\r\n\t-- \tassert(not (t.RBXScriptConnection(nil)))\r\n\t-- \tassert(not (t.RBXScriptConnection(Vector3.new())))\r\n\t-- end)\r\n\r\n\tit(\"should support wrapping function types\", function()\r\n\t\tlocal checkFoo = t.tuple(t.string, t.number, t.optional(t.string))\r\n\t\tlocal foo = t.wrap(function(a, b, c)\r\n\t\t\tlocal result = string.format(\"%s %d\", a, b)\r\n\t\t\tif c then\r\n\t\t\t\tresult = result .. \" \" .. c\r\n\t\t\tend\r\n\t\t\treturn result\r\n\t\tend, checkFoo)\r\n\r\n\t\tassert(not (pcall(foo)))\r\n\t\tassert(not (pcall(foo, \"a\")))\r\n\t\tassert(not (pcall(foo, 2)))\r\n\t\tassert(pcall(foo, \"a\", 1))\r\n\t\tassert(pcall(foo, \"a\", 1, \"b\"))\r\n\tend)\r\n\r\n\tit(\"should support strict types\", function()\r\n\t\tlocal myType = t.strict(t.tuple(t.string, t.number))\r\n\t\tassert(not (pcall(function()\r\n\t\t\tmyType(\"a\", \"b\")\r\n\t\tend)))\r\n\t\tassert(pcall(function()\r\n\t\t\tmyType(\"a\", 1)\r\n\t\tend))\r\n\tend)\r\n\r\n\tit(\"should support common OOP types\", function()\r\n\t\tlocal MyClass = {}\r\n\t\tMyClass.__index = MyClass\r\n\r\n\t\tfunction MyClass.new()\r\n\t\t\tlocal self = setmetatable({}, MyClass)\r\n\t\t\treturn self\r\n\t\tend\r\n\r\n\t\tlocal function instanceOfClass(class)\r\n\t\t\treturn function(value)\r\n\t\t\t\tlocal tableSuccess, tableErrMsg = t.table(value)\r\n\t\t\t\tif not tableSuccess then\r\n\t\t\t\t\treturn false, tableErrMsg or \"\"\r\n\t\t\t\tend\r\n\r\n\t\t\t\tlocal mt = getmetatable(value)\r\n\t\t\t\tif not mt or mt.__index ~= class then\r\n\t\t\t\t\treturn false, \"bad member of class\"\r\n\t\t\t\tend\r\n\r\n\t\t\t\treturn true\r\n\t\t\tend\r\n\t\tend\r\n\r\n\t\tlocal instanceOfMyClass = instanceOfClass(MyClass)\r\n\r\n\t\tlocal myObject = MyClass.new()\r\n\t\tassert(instanceOfMyClass(myObject))\r\n\t\tassert(not (instanceOfMyClass({})))\r\n\t\tassert(not (instanceOfMyClass()))\r\n\tend)\r\n\r\n\tit(\"should not treat NaN as numbers\", function()\r\n\t\tassert(t.number(1))\r\n\t\tassert(not (t.number(0/0)))\r\n\t\tassert(not (t.number(\"1\")))\r\n\tend)\r\n\r\n\tit(\"should not treat numbers as NaN\", function()\r\n\t\tassert(not (t.nan(1)))\r\n\t\tassert(t.nan(0/0))\r\n\t\tassert(not (t.nan(\"1\")))\r\n\tend)\r\n\r\n\tit(\"should allow union of number and NaN\", function()\r\n\t\tlocal numberOrNaN = t.union(t.number, t.nan)\r\n\t\tassert(numberOrNaN(1))\r\n\t\tassert(numberOrNaN(0/0))\r\n\t\tassert(not (numberOrNaN(\"1\")))\r\n\tend)\r\n\r\n\tit(\"should support non-string keys for interfaces\", function()\r\n\t\tlocal key = {}\r\n\t\tlocal myInterface = t.interface({ [key] = t.number })\r\n\t\tassert(myInterface({ [key] = 1 }))\r\n\t\tassert(not (myInterface({ [key] = \"1\" })))\r\n\tend)\r\n\r\n\tit(\"should support failing on non-string keys for strict interfaces\", function()\r\n\t\tlocal myInterface = t.strictInterface({ a = t.number })\r\n\t\tassert(not (myInterface({ a = 1, [{}] = 2 })))\r\n\tend)\r\n\r\n\tit(\"should support children\", function()\r\n\t\tlocal myInterface = t.interface({\r\n\t\t\tbuttonInFrame = t.intersection(t.instanceOf(\"Frame\"), t.children({\r\n\t\t\t\tMyButton = t.instanceOf(\"ImageButton\")\r\n\t\t\t}))\r\n\t\t})\r\n\r\n\t\tassert(not (t.children({})(5)))\r\n\t\tassert(not (myInterface({ buttonInFrame = Instance.new(\"Frame\") })))\r\n\r\n\t\tdo\r\n\t\t\tlocal frame = Instance.new(\"Frame\")\r\n\t\t\tlocal button = Instance.new(\"ImageButton\", frame)\r\n\t\t\tbutton.Name = \"MyButton\"\r\n\t\t\tassert(myInterface({ buttonInFrame = frame }))\r\n\t\tend\r\n\r\n\t\tdo\r\n\t\t\tlocal frame = Instance.new(\"Frame\")\r\n\t\t\tlocal button = Instance.new(\"ImageButton\", frame)\r\n\t\t\tbutton.Name = \"NotMyButton\"\r\n\t\t\tassert(not (myInterface({ buttonInFrame = frame })))\r\n\t\tend\r\n\r\n\t\tdo\r\n\t\t\tlocal frame = Instance.new(\"Frame\")\r\n\t\t\tlocal button = Instance.new(\"TextButton\", frame)\r\n\t\t\tbutton.Name = \"MyButton\"\r\n\t\t\tassert(not (myInterface({ buttonInFrame = frame })))\r\n\t\tend\r\n\r\n\t\tdo\r\n\t\t\tlocal frame = Instance.new(\"Frame\")\r\n\t\t\tlocal button1 = Instance.new(\"ImageButton\", frame)\r\n\t\t\tbutton1.Name = \"MyButton\"\r\n\t\t\tlocal button2 = Instance.new(\"ImageButton\", frame)\r\n\t\t\tbutton2.Name = \"MyButton\"\r\n\t\t\tassert(not (myInterface({ buttonInFrame = frame })))\r\n\t\tend\r\n\tend)\r\n\r\n\tit(\"should support t.instanceOf shorthand\", function()\r\n\t\tlocal myInterface = t.interface({\r\n\t\t\tbuttonInFrame = t.instanceOf(\"Frame\", {\r\n\t\t\t\tMyButton = t.instanceOf(\"ImageButton\")\r\n\t\t\t})\r\n\t\t})\r\n\r\n\t\tassert(not (t.children({})(5)))\r\n\t\tassert(not (myInterface({ buttonInFrame = Instance.new(\"Frame\") })))\r\n\r\n\t\tdo\r\n\t\t\tlocal frame = Instance.new(\"Frame\")\r\n\t\t\tlocal button = Instance.new(\"ImageButton\", frame)\r\n\t\t\tbutton.Name = \"MyButton\"\r\n\t\t\tassert(myInterface({ buttonInFrame = frame }))\r\n\t\tend\r\n\r\n\t\tdo\r\n\t\t\tlocal frame = Instance.new(\"Frame\")\r\n\t\t\tlocal button = Instance.new(\"ImageButton\", frame)\r\n\t\t\tbutton.Name = \"NotMyButton\"\r\n\t\t\tassert(not (myInterface({ buttonInFrame = frame })))\r\n\t\tend\r\n\r\n\t\tdo\r\n\t\t\tlocal frame = Instance.new(\"Frame\")\r\n\t\t\tlocal button = Instance.new(\"TextButton\", frame)\r\n\t\t\tbutton.Name = \"MyButton\"\r\n\t\t\tassert(not (myInterface({ buttonInFrame = frame })))\r\n\t\tend\r\n\r\n\t\tdo\r\n\t\t\tlocal frame = Instance.new(\"Frame\")\r\n\t\t\tlocal button1 = Instance.new(\"ImageButton\", frame)\r\n\t\t\tbutton1.Name = \"MyButton\"\r\n\t\t\tlocal button2 = Instance.new(\"ImageButton\", frame)\r\n\t\t\tbutton2.Name = \"MyButton\"\r\n\t\t\tassert(not (myInterface({ buttonInFrame = frame })))\r\n\t\tend\r\n\tend)\r\n\r\n\tit(\"should support t.instanceIsA shorthand\", function()\r\n\t\tlocal myInterface = t.interface({\r\n\t\t\tbuttonInFrame = t.instanceIsA(\"Frame\", {\r\n\t\t\t\tMyButton = t.instanceIsA(\"ImageButton\")\r\n\t\t\t})\r\n\t\t})\r\n\r\n\t\tassert(not (t.children({})(5)))\r\n\t\tassert(not (myInterface({ buttonInFrame = Instance.new(\"Frame\") })))\r\n\r\n\t\tdo\r\n\t\t\tlocal frame = Instance.new(\"Frame\")\r\n\t\t\tlocal button = Instance.new(\"ImageButton\", frame)\r\n\t\t\tbutton.Name = \"MyButton\"\r\n\t\t\tassert(myInterface({ buttonInFrame = frame }))\r\n\t\tend\r\n\r\n\t\tdo\r\n\t\t\tlocal frame = Instance.new(\"Frame\")\r\n\t\t\tlocal button = Instance.new(\"ImageButton\", frame)\r\n\t\t\tbutton.Name = \"NotMyButton\"\r\n\t\t\tassert(not (myInterface({ buttonInFrame = frame })))\r\n\t\tend\r\n\r\n\t\tdo\r\n\t\t\tlocal frame = Instance.new(\"Frame\")\r\n\t\t\tlocal button = Instance.new(\"TextButton\", frame)\r\n\t\t\tbutton.Name = \"MyButton\"\r\n\t\t\tassert(not (myInterface({ buttonInFrame = frame })))\r\n\t\tend\r\n\r\n\t\tdo\r\n\t\t\tlocal frame = Instance.new(\"Frame\")\r\n\t\t\tlocal button1 = Instance.new(\"ImageButton\", frame)\r\n\t\t\tbutton1.Name = \"MyButton\"\r\n\t\t\tlocal button2 = Instance.new(\"ImageButton\", frame)\r\n\t\t\tbutton2.Name = \"MyButton\"\r\n\t\t\tassert(not (myInterface({ buttonInFrame = frame })))\r\n\t\tend\r\n\tend)\r\n\r\n\tit(\"should support t.match\", function()\r\n\t\tlocal check = t.match(\"%d+\")\r\n\t\tassert(check(\"123\"))\r\n\t\tassert(not (check(\"abc\")))\r\n\t\tassert(not (check()))\r\n\tend)\r\n\r\n\tit(\"should support t.keyOf\", function()\r\n\t\tlocal myNewEnum = {\r\n\t\t\tOptionA = {},\r\n\t\t\tOptionB = {},\r\n\t\t}\r\n\t\tlocal check = t.keyOf(myNewEnum)\r\n\t\tassert(check(\"OptionA\"))\r\n\t\tassert(not (check(\"OptionC\")))\r\n\tend)\r\n\r\n\tit(\"should support t.valueOf\", function()\r\n\t\tlocal myNewEnum = {\r\n\t\t\tOptionA = {},\r\n\t\t\tOptionB = {},\r\n\t\t}\r\n\t\tlocal check = t.valueOf(myNewEnum)\r\n\t\tassert(check(myNewEnum.OptionA))\r\n\t\tassert(not (check(1010)))\r\n\tend)\r\n\r\n\tit(\"should support t.strictArray\", function()\r\n\t\tlocal fixedArrayCheck = t.strictArray(t.number, t.number)\r\n\r\n\t\tassert(fixedArrayCheck({1, 2}))\r\n\t\tassert(not fixedArrayCheck({1, 2, 3}))\r\n\t\tassert(not fixedArrayCheck({10}))\r\n\t\tassert(not fixedArrayCheck({\"Hello\", 10}))\r\n\t\tassert(not fixedArrayCheck({ Foo = \"Bar\" }))\r\n\r\n\t\tlocal fixedArrayCheck2 = t.strictArray(t.number, t.number, t.optional(t.string))\r\n\r\n\t\tassert(fixedArrayCheck2({10, 20}))\r\n\t\tassert(fixedArrayCheck2({10, 20, \"Hello\"}))\r\n\t\tassert(not fixedArrayCheck2({10, 20, 30}))\r\n\tend)\r\nend"}},"Children":[],"Metadata":{"ignoreUnknownInstances":false}},"1a31bb8458eefe0db2d00eab15f6b14f":{"Id":"1a31bb8458eefe0db2d00eab15f6b14f","Parent":"5d73467a1d588843ea200ceeebce3eb5","Name":"Baseplate","ClassName":"Part","Properties":{"Locked":{"Bool":true},"Position":{"Vector3":[0.0,-10.0,0.0]},"Size":{"Vector3":[512.0,20.0,512.0]},"Color":{"Color3":[0.38823,0.37254,0.38823]},"Anchored":{"Bool":true}},"Children":[],"Metadata":{"ignoreUnknownInstances":true}},"89734f1df997de85fd2bdd427ddf34fb":{"Id":"89734f1df997de85fd2bdd427ddf34fb","Parent":"e412d57eace8911b86fabef6e8521d77","Name":"Wormhole","ClassName":"ModuleScript","Properties":{"Source":{"String":"local ReplicatedStorage: ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\r\nlocal RunService: RunService = game:GetService(\"RunService\")\r\n\r\nlocal t = require(script.Parent.Parent.t)\r\nlocal Promise = require(script.Parent.Parent.Promise)\r\n\r\nlocal types = require(script.Parent.Types)\r\nlocal AwaitForValue = require(script.Parent.Promises.promiseAwaitValue)\r\n\r\nlocal Context = require(script.Parent.Context)\r\nlocal Subscription = require(script.Parent.Subscription)\r\n\r\ntype IContext = types.IContext\r\ntype ISubscription = types.ISubscription\r\ntype IWormhole = types.IWormhole\r\ntype ContextBlock = types.ContextBlock\r\ntype IPackage = types.IPackage\r\n\r\nlocal RemoteFolderName= \"Portal\"\r\nlocal Storage: Folder = ReplicatedStorage:FindFirstChild(RemoteFolderName) :: Folder\r\n\r\nif not Storage then\r\n\tif RunService:IsServer() then\r\n\t\tStorage = Instance.new(\"Folder\")\r\n\t\tStorage.Name = RemoteFolderName\r\n\t\tStorage.Parent = ReplicatedStorage\r\n\telse\r\n\t\tStorage = ReplicatedStorage:WaitForChild(RemoteFolderName) :: Folder\r\n\tend\r\nend\r\n\r\nlocal function createPackage(context: string, action: string, data: any): IPackage\r\n\treturn {\r\n\t\tContext = context,\r\n\t\tAction = action,\r\n\t\tTimestamp = DateTime.now(),\r\n\t\tPayload = data\r\n\t} :: IPackage\r\nend\r\n\r\nlocal Wormhole: IWormhole\r\nWormhole._Storage = Storage\r\nWormhole._Contexts = {}\r\nWormhole.__index = Wormhole\r\n\r\nfunction Wormhole.new(): IWormhole\r\n\tlocal self = setmetatable({}, Wormhole)\r\n\treturn self :: IWormhole\r\nend\r\n\r\nfunction Wormhole.is(wormhole: IWormhole): boolean\r\n\treturn types.isWormhole(wormhole)\r\nend\r\n\r\nfunction Wormhole.awaitContext(wormhole: IWormhole, context: string, timeout: number?): ContextBlock\r\n\tlocal check = t.strict(t.tuple(t.string, t.optional(t.number)))\r\n\tcheck(context, timeout)\r\n\r\n\tlocal contextPromise = AwaitForValue(context, wormhole._Contexts)\r\n\tif timeout then \r\n\t\tcontextPromise:timeout(timeout)\r\n\tend\r\n\tcontextPromise:catch(function(e)\r\n\t\twarn(\"Uh oh! Something went wrong awaiting context\\n\", e)\r\n\r\n\t\tif not wormhole._Contexts[context] then\r\n\t\t\twormhole._Contexts[context] = Wormhole.addContext(wormhole, context)\r\n\t\tend\r\n\t\treturn wormhole._Contexts[context]\r\n\tend)\r\n\r\n\treturn contextPromise:expect() :: ContextBlock\r\nend\r\n\r\nfunction Wormhole.addContext(wormhole: IWormhole, context: string): ContextBlock\r\n\tlocal new: ContextBlock = {\r\n\t\tRemote = Instance.new(\"RemoteEvent\"),\r\n\t\tContext = Context.new(context, wormhole),\r\n\t\tActions = {}\r\n\t}\r\n\twormhole._Contexts[context] = new\r\n\r\n\treturn wormhole._Contexts[context]\r\nend\r\n\r\nfunction Wormhole.makeSubscription(wormhole: IWormhole, context: string, action: string): ISubscription\r\n\tlocal subscription: ISubscription\r\n\tsubscription = Subscription.new(context, action)\r\n\treturn subscription\r\nend\r\n\r\nfunction Wormhole.doSubscribe(wormhole: IWormhole, subscription: ISubscription, callback: ()->()?): ()\r\n\t\r\n\tlocal eventConnection: RBXScriptConnection\r\n\tlocal context: ContextBlock = wormhole.awaitContext(subscription.Context)\r\n\tif RunService:IsServer() then\r\n\t\teventConnection = context.Remote.OnServerEvent:Connect(\r\n\t\t\tfunction(listener: Player, package: IPackage)\r\n\t\t\t\tlocal check = t.strict(t.instanceIsA(\"Player\"))\r\n\t\t\t\tcheck(listener)\r\n\t\t\tend\r\n\t\t)\r\n\telse\r\n\t\teventConnection = context.Remote.OnClientEvent:Connect(\r\n\t\t\tfunction(listener: Player, package: IPackage)\r\n\t\t\t\tlocal check = t.strict(t.instanceIsA(\"Player\"))\r\n\t\t\t\tcheck(listener)\r\n\t\t\tend\r\n\t\t)\r\n\tend\r\n\r\n\treturn function()\r\n\t\teventConnection:Disconnect()\r\n\tend\r\nend\r\n\r\nreturn Wormhole"}},"Children":[],"Metadata":{"ignoreUnknownInstances":false}},"ee222f38fa8be78c47f18fd875ac7854":{"Id":"ee222f38fa8be78c47f18fd875ac7854","Parent":"7fbc840dac8c567469e92bc32ba7f9df","Name":"Packages","ClassName":"Folder","Properties":{},"Children":["8d7217c7f2aaf98a45b764cd6f5e70a3","2e2d4268ad91d40d489844d149b7c87e","3860334f5903be77d1957718f152993f","e412d57eace8911b86fabef6e8521d77"],"Metadata":{"ignoreUnknownInstances":false}},"a143059ecae834aee41b94f5ac29f512":{"Id":"a143059ecae834aee41b94f5ac29f512","Parent":"372383b65caa3b15b65ef42feec874b8","Name":"SoundService","ClassName":"SoundService","Properties":{"RespectFilteringEnabled":{"Bool":true}},"Children":[],"Metadata":{"ignoreUnknownInstances":true}},"13407f4c65e57105e82422a6a09fcfa8":{"Id":"13407f4c65e57105e82422a6a09fcfa8","Parent":"2e2d4268ad91d40d489844d149b7c87e","Name":"evaera_promise@3.1.0","ClassName":"Folder","Properties":{},"Children":["9cd69536a0dc973cffeed65b16a569e0"],"Metadata":{"ignoreUnknownInstances":false}},"46bcc92ca5dc93da75ba685ae7cb4991":{"Id":"46bcc92ca5dc93da75ba685ae7cb4991","Parent":"d539d2b3547c9166dae5ffd367a37cb3","Name":"IContext","ClassName":"ModuleScript","Properties":{"Source":{"String":"local t = require(script.Parent.Parent.Parent.t)\r\n\r\nlocal IsContext = t.interface({\r\n\tName = t.string,\r\n\tSubscriptions = t.map(t.string, t.callback)\r\n})\r\n\r\nexport type IContext = {\r\n\tName: string,\r\n\tSubscriptions: {[string]: ()->nil},\r\n\t\r\n\t__index: IContext,\r\n\tnew: (context: string, provider: any) -> IContext,\r\n\tis: (obj: any) -> boolean,\r\n\r\n\tPublish: (self: IContext, action: string, data: any) -> (),\r\n\tSubscribe: (self: IContext, action: string, callback: () -> ()) -> (),\r\n\tDestroy: (self: IContext) -> nil\r\n}\r\n\r\nreturn function(obj)\r\n\treturn IsContext(obj) :: boolean\r\nend"}},"Children":[],"Metadata":{"ignoreUnknownInstances":false}},"2e2d4268ad91d40d489844d149b7c87e":{"Id":"2e2d4268ad91d40d489844d149b7c87e","Parent":"ee222f38fa8be78c47f18fd875ac7854","Name":"_Index","ClassName":"Folder","Properties":{},"Children":["13407f4c65e57105e82422a6a09fcfa8","9ee814837a27b11857e89563135cd306"],"Metadata":{"ignoreUnknownInstances":false}},"3860334f5903be77d1957718f152993f":{"Id":"3860334f5903be77d1957718f152993f","Parent":"ee222f38fa8be78c47f18fd875ac7854","Name":"t","ClassName":"ModuleScript","Properties":{"Source":{"String":"return require(script.Parent._Index[\"shanebutt_t@1.3.1\"][\"t\"])\n"}},"Children":[],"Metadata":{"ignoreUnknownInstances":false}},"6978a188358d64bfb2103712202a9922":{"Id":"6978a188358d64bfb2103712202a9922","Parent":"d539d2b3547c9166dae5ffd367a37cb3","Name":"ISubscription","ClassName":"ModuleScript","Properties":{"Source":{"String":"local t = require(script.Parent.Parent.Parent.t)\n\nlocal IsSUbscription = t.interface({\n\tContext = t.string,\n\tAction = t.string,\n\tCallback = t.optional(t.callback()),\n})\n\nexport type ISubscription = {\n\tContext: string,\n\tAction: string,\n\tCallback: () -> nil,\n\n\t__index: ISubscription,\n\n\tnew: (context: string, action: string, callback: () -> ()?) -> ISubscription,\n\tis: (obj: any) -> boolean,\n\n\tSubscribe: (self: ISubscription, callback: () -> nil) -> ISubscription,\n}\n\nreturn function(obj)\n\treturn IsSubscription(obj) :: boolean\nend\n"}},"Children":[],"Metadata":{"ignoreUnknownInstances":false}},"372383b65caa3b15b65ef42feec874b8":{"Id":"372383b65caa3b15b65ef42feec874b8","Parent":"00000000000000000000000000000000","Name":"portal","ClassName":"DataModel","Properties":{},"Children":["bc7710f6aad3249798ac01ac70c608b3","7fbc840dac8c567469e92bc32ba7f9df","a143059ecae834aee41b94f5ac29f512","5d73467a1d588843ea200ceeebce3eb5"],"Metadata":{"ignoreUnknownInstances":true}},"7fbc840dac8c567469e92bc32ba7f9df":{"Id":"7fbc840dac8c567469e92bc32ba7f9df","Parent":"372383b65caa3b15b65ef42feec874b8","Name":"ReplicatedStorage","ClassName":"ReplicatedStorage","Properties":{},"Children":["ee222f38fa8be78c47f18fd875ac7854"],"Metadata":{"ignoreUnknownInstances":true}},"9cd69536a0dc973cffeed65b16a569e0":{"Id":"9cd69536a0dc973cffeed65b16a569e0","Parent":"13407f4c65e57105e82422a6a09fcfa8","Name":"promise","ClassName":"ModuleScript","Properties":{"Source":{"String":"--[[\r\n\tAn implementation of Promises similar to Promise/A+.\r\n]]\r\n\r\nlocal ERROR_NON_PROMISE_IN_LIST = \"Non-promise value passed into %s at index %s\"\r\nlocal ERROR_NON_LIST = \"Please pass a list of promises to %s\"\r\nlocal ERROR_NON_FUNCTION = \"Please pass a handler function to %s!\"\r\nlocal MODE_KEY_METATABLE = {__mode = \"k\"}\r\n\r\n--[[\r\n\tCreates an enum dictionary with some metamethods to prevent common mistakes.\r\n]]\r\nlocal function makeEnum(enumName, members)\r\n\tlocal enum = {}\r\n\r\n\tfor _, memberName in ipairs(members) do\r\n\t\tenum[memberName] = memberName\r\n\tend\r\n\r\n\treturn setmetatable(enum, {\r\n\t\t__index = function(_, k)\r\n\t\t\terror(string.format(\"%s is not in %s!\", k, enumName), 2)\r\n\t\tend,\r\n\t\t__newindex = function()\r\n\t\t\terror(string.format(\"Creating new members in %s is not allowed!\", enumName), 2)\r\n\t\tend,\r\n\t})\r\nend\r\n\r\n--[=[\r\n\tAn object to represent runtime errors that occur during execution.\r\n\tPromises that experience an error like this will be rejected with\r\n\tan instance of this object.\r\n\r\n\t@class Error\r\n]=]\r\nlocal Error do\r\n\tError = {\r\n\t\tKind = makeEnum(\"Promise.Error.Kind\", {\r\n\t\t\t\"ExecutionError\",\r\n\t\t\t\"AlreadyCancelled\",\r\n\t\t\t\"NotResolvedInTime\",\r\n\t\t\t\"TimedOut\",\r\n\t\t}),\r\n\t}\r\n\tError.__index = Error\r\n\r\n\tfunction Error.new(options, parent)\r\n\t\toptions = options or {}\r\n\t\treturn setmetatable({\r\n\t\t\terror = tostring(options.error) or \"[This error has no error text.]\",\r\n\t\t\ttrace = options.trace,\r\n\t\t\tcontext = options.context,\r\n\t\t\tkind = options.kind,\r\n\t\t\tparent = parent,\r\n\t\t\tcreatedTick = os.clock(),\r\n\t\t\tcreatedTrace = debug.traceback(),\r\n\t\t}, Error)\r\n\tend\r\n\r\n\tfunction Error.is(anything)\r\n\t\tif type(anything) == \"table\" then\r\n\t\t\tlocal metatable = getmetatable(anything)\r\n\r\n\t\t\tif type(metatable) == \"table\" then\r\n\t\t\t\treturn rawget(anything, \"error\") ~= nil and type(rawget(metatable, \"extend\")) == \"function\"\r\n\t\t\tend\r\n\t\tend\r\n\r\n\t\treturn false\r\n\tend\r\n\r\n\tfunction Error.isKind(anything, kind)\r\n\t\tassert(kind ~= nil, \"Argument #2 to Promise.Error.isKind must not be nil\")\r\n\r\n\t\treturn Error.is(anything) and anything.kind == kind\r\n\tend\r\n\r\n\tfunction Error:extend(options)\r\n\t\toptions = options or {}\r\n\r\n\t\toptions.kind = options.kind or self.kind\r\n\r\n\t\treturn Error.new(options, self)\r\n\tend\r\n\r\n\tfunction Error:getErrorChain()\r\n\t\tlocal runtimeErrors = { self }\r\n\r\n\t\twhile runtimeErrors[#runtimeErrors].parent do\r\n\t\t\ttable.insert(runtimeErrors, runtimeErrors[#runtimeErrors].parent)\r\n\t\tend\r\n\r\n\t\treturn runtimeErrors\r\n\tend\r\n\r\n\tfunction Error:__tostring()\r\n\t\tlocal errorStrings = {\r\n\t\t\tstring.format(\"-- Promise.Error(%s) --\", self.kind or \"?\"),\r\n\t\t}\r\n\r\n\t\tfor _, runtimeError in ipairs(self:getErrorChain()) do\r\n\t\t\ttable.insert(errorStrings, table.concat({\r\n\t\t\t\truntimeError.trace or runtimeError.error,\r\n\t\t\t\truntimeError.context,\r\n\t\t\t}, \"\\n\"))\r\n\t\tend\r\n\r\n\t\treturn table.concat(errorStrings, \"\\n\")\r\n\tend\r\nend\r\n\r\n--[[\r\n\tPacks a number of arguments into a table and returns its length.\r\n\r\n\tUsed to cajole varargs without dropping sparse values.\r\n]]\r\nlocal function pack(...)\r\n\treturn select(\"#\", ...), { ... }\r\nend\r\n\r\n--[[\r\n\tReturns first value (success), and packs all following values.\r\n]]\r\nlocal function packResult(success, ...)\r\n\treturn success, select(\"#\", ...), { ... }\r\nend\r\n\r\nlocal function makeErrorHandler(traceback)\r\n\tassert(traceback ~= nil)\r\n\r\n\treturn function(err)\r\n\t\t-- If the error object is already a table, forward it directly.\r\n\t\t-- Should we extend the error here and add our own trace?\r\n\r\n\t\tif type(err) == \"table\" then\r\n\t\t\treturn err\r\n\t\tend\r\n\r\n\t\treturn Error.new({\r\n\t\t\terror = err,\r\n\t\t\tkind = Error.Kind.ExecutionError,\r\n\t\t\ttrace = debug.traceback(tostring(err), 2),\r\n\t\t\tcontext = \"Promise created at:\\n\\n\" .. traceback,\r\n\t\t})\r\n\tend\r\nend\r\n\r\n--[[\r\n\tCalls a Promise executor with error handling.\r\n]]\r\nlocal function runExecutor(traceback, callback, ...)\r\n\treturn packResult(xpcall(callback, makeErrorHandler(traceback), ...))\r\nend\r\n\r\n--[[\r\n\tCreates a function that invokes a callback with correct error handling and\r\n\tresolution mechanisms.\r\n]]\r\nlocal function createAdvancer(traceback, callback, resolve, reject)\r\n\treturn function(...)\r\n\t\tlocal ok, resultLength, result = runExecutor(traceback, callback, ...)\r\n\r\n\t\tif ok then\r\n\t\t\tresolve(unpack(result, 1, resultLength))\r\n\t\telse\r\n\t\t\treject(result[1])\r\n\t\tend\r\n\tend\r\nend\r\n\r\nlocal function isEmpty(t)\r\n\treturn next(t) == nil\r\nend\r\n\r\n--[=[\r\n\tAn enum value used to represent the Promise's status.\r\n\t@interface Status\r\n\t@tag enum\r\n\t@within Promise\r\n\t.Started \"Started\" -- The Promise is executing, and not settled yet.\r\n\t.Resolved \"Resolved\" -- The Promise finished successfully.\r\n\t.Rejected \"Rejected\" -- The Promise was rejected.\r\n\t.Cancelled \"Cancelled\" -- The Promise was cancelled before it finished.\r\n]=]\r\n--[=[\r\n\t@prop Status Status\r\n\t@within Promise\r\n\t@readonly\r\n\t@tag enums\r\n\tA table containing all members of the `Status` enum, e.g., `Promise.Status.Resolved`.\r\n]=]\r\n--[=[\r\n\tA Promise is an object that represents a value that will exist in the future, but doesn't right now.\r\n\tPromises allow you to then attach callbacks that can run once the value becomes available (known as *resolving*),\r\n\tor if an error has occurred (known as *rejecting*).\r\n\r\n\t@class Promise\r\n\t@__index prototype\r\n]=]\r\nlocal Promise = {\r\n\tError = Error,\r\n\tStatus = makeEnum(\"Promise.Status\", {\"Started\", \"Resolved\", \"Rejected\", \"Cancelled\"}),\r\n\t_getTime = os.clock,\r\n\t_timeEvent = game:GetService(\"RunService\").Heartbeat,\r\n}\r\nPromise.prototype = {}\r\nPromise.__index = Promise.prototype\r\n\r\nfunction Promise._new(traceback, callback, parent)\r\n\tif parent ~= nil and not Promise.is(parent) then\r\n\t\terror(\"Argument #2 to Promise.new must be a promise or nil\", 2)\r\n\tend\r\n\r\n\tlocal self = {\r\n\t\t-- Used to locate where a promise was created\r\n\t\t_source = traceback,\r\n\r\n\t\t_status = Promise.Status.Started,\r\n\r\n\t\t-- A table containing a list of all results, whether success or failure.\r\n\t\t-- Only valid if _status is set to something besides Started\r\n\t\t_values = nil,\r\n\r\n\t\t-- Lua doesn't like sparse arrays very much, so we explicitly store the\r\n\t\t-- length of _values to handle middle nils.\r\n\t\t_valuesLength = -1,\r\n\r\n\t\t-- Tracks if this Promise has no error observers..\r\n\t\t_unhandledRejection = true,\r\n\r\n\t\t-- Queues representing functions we should invoke when we update!\r\n\t\t_queuedResolve = {},\r\n\t\t_queuedReject = {},\r\n\t\t_queuedFinally = {},\r\n\r\n\t\t-- The function to run when/if this promise is cancelled.\r\n\t\t_cancellationHook = nil,\r\n\r\n\t\t-- The \"parent\" of this promise in a promise chain. Required for\r\n\t\t-- cancellation propagation upstream.\r\n\t\t_parent = parent,\r\n\r\n\t\t-- Consumers are Promises that have chained onto this one.\r\n\t\t-- We track them for cancellation propagation downstream.\r\n\t\t_consumers = setmetatable({}, MODE_KEY_METATABLE),\r\n\t}\r\n\r\n\tif parent and parent._status == Promise.Status.Started then\r\n\t\tparent._consumers[self] = true\r\n\tend\r\n\r\n\tsetmetatable(self, Promise)\r\n\r\n\tlocal function resolve(...)\r\n\t\tself:_resolve(...)\r\n\tend\r\n\r\n\tlocal function reject(...)\r\n\t\tself:_reject(...)\r\n\tend\r\n\r\n\tlocal function onCancel(cancellationHook)\r\n\t\tif cancellationHook then\r\n\t\t\tif self._status == Promise.Status.Cancelled then\r\n\t\t\t\tcancellationHook()\r\n\t\t\telse\r\n\t\t\t\tself._cancellationHook = cancellationHook\r\n\t\t\tend\r\n\t\tend\r\n\r\n\t\treturn self._status == Promise.Status.Cancelled\r\n\tend\r\n\r\n\tcoroutine.wrap(function()\r\n\t\tlocal ok, _, result = runExecutor(\r\n\t\t\tself._source,\r\n\t\t\tcallback,\r\n\t\t\tresolve,\r\n\t\t\treject,\r\n\t\t\tonCancel\r\n\t\t)\r\n\r\n\t\tif not ok then\r\n\t\t\treject(result[1])\r\n\t\tend\r\n\tend)()\r\n\r\n\treturn self\r\nend\r\n\r\n--[=[\r\n\tConstruct a new Promise that will be resolved or rejected with the given callbacks.\r\n\r\n\tIf you `resolve` with a Promise, it will be chained onto.\r\n\r\n\tYou can safely yield within the executor function and it will not block the creating thread.\r\n\r\n\t```lua\r\n\tlocal myFunction()\r\n\t\treturn Promise.new(function(resolve, reject, onCancel)\r\n\t\t\twait(1)\r\n\t\t\tresolve(\"Hello world!\")\r\n\t\tend)\r\n\tend\r\n\r\n\tmyFunction():andThen(print)\r\n\t```\r\n\r\n\tYou do not need to use `pcall` within a Promise. Errors that occur during execution will be caught and turned into a rejection automatically. If `error()` is called with a table, that table will be the rejection value. Otherwise, string errors will be converted into `Promise.Error(Promise.Error.Kind.ExecutionError)` objects for tracking debug information.\r\n\r\n\tYou may register an optional cancellation hook by using the `onCancel` argument:\r\n\r\n\t* This should be used to abort any ongoing operations leading up to the promise being settled.\r\n\t* Call the `onCancel` function with a function callback as its only argument to set a hook which will in turn be called when/if the promise is cancelled.\r\n\t* `onCancel` returns `true` if the Promise was already cancelled when you called `onCancel`.\r\n\t* Calling `onCancel` with no argument will not override a previously set cancellation hook, but it will still return `true` if the Promise is currently cancelled.\r\n\t* You can set the cancellation hook at any time before resolving.\r\n\t* When a promise is cancelled, calls to `resolve` or `reject` will be ignored, regardless of if you set a cancellation hook or not.\r\n\r\n\t@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler: () -> boolean)) -> ()\r\n\t@return Promise\r\n]=]\r\nfunction Promise.new(executor)\r\n\treturn Promise._new(debug.traceback(nil, 2), executor)\r\nend\r\n\r\nfunction Promise:__tostring()\r\n\treturn string.format(\"Promise(%s)\", self._status)\r\nend\r\n\r\n--[=[\r\n\tThe same as [Promise.new](/api/Promise#new), except execution begins after the next `Heartbeat` event.\r\n\r\n\tThis is a spiritual replacement for `spawn`, but it does not suffer from the same [issues](https://eryn.io/gist/3db84579866c099cdd5bb2ff37947cec) as `spawn`.\r\n\r\n\t```lua\r\n\tlocal function waitForChild(instance, childName, timeout)\r\n\t  return Promise.defer(function(resolve, reject)\r\n\t\tlocal child = instance:WaitForChild(childName, timeout)\r\n\r\n\t\t;(child and resolve or reject)(child)\r\n\t  end)\r\n\tend\r\n\t```\r\n\r\n\t@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler: () -> boolean)) -> ()\r\n\t@return Promise\r\n]=]\r\nfunction Promise.defer(callback)\r\n\tlocal traceback = debug.traceback(nil, 2)\r\n\tlocal promise\r\n\tpromise = Promise._new(traceback, function(resolve, reject, onCancel)\r\n\t\tlocal connection\r\n\t\tconnection = Promise._timeEvent:Connect(function()\r\n\t\t\tconnection:Disconnect()\r\n\t\t\tlocal ok, _, result = runExecutor(traceback, callback, resolve, reject, onCancel)\r\n\r\n\t\t\tif not ok then\r\n\t\t\t\treject(result[1])\r\n\t\t\tend\r\n\t\tend)\r\n\tend)\r\n\r\n\treturn promise\r\nend\r\n\r\n-- Backwards compatibility\r\nPromise.async = Promise.defer\r\n\r\n--[=[\r\n\tCreates an immediately resolved Promise with the given value.\r\n\r\n\t@param ... any\r\n\t@return Promise<...any>\r\n]=]\r\nfunction Promise.resolve(...)\r\n\tlocal length, values = pack(...)\r\n\treturn Promise._new(debug.traceback(nil, 2), function(resolve)\r\n\t\tresolve(unpack(values, 1, length))\r\n\tend)\r\nend\r\n\r\n--[=[\r\n\tCreates an immediately rejected Promise with the given value.\r\n\r\n\t:::caution\r\n\tSomething needs to consume this rejection (i.e. `:catch()` it), otherwise it will emit an unhandled Promise rejection warning on the next frame. Thus, you should not create and store rejected Promises for later use. Only create them on-demand as needed.\r\n\t:::\r\n\r\n\t```lua\r\n\t-- Example using Promise.resolve to deliver cached values:\r\n\tfunction getSomething(name)\r\n\t\tif cache[name] then\r\n\t\t\treturn Promise.resolve(cache[name])\r\n\t\telse\r\n\t\t\treturn Promise.new(function(resolve, reject)\r\n\t\t\t\tlocal thing = getTheThing()\r\n\t\t\t\tcache[name] = thing\r\n\r\n\t\t\t\tresolve(thing)\r\n\t\t\tend)\r\n\t\tend\r\n\tend\r\n\t```\r\n\r\n\t@param ... any\r\n\t@return Promise<...any>\r\n]=]\r\nfunction Promise.reject(...)\r\n\tlocal length, values = pack(...)\r\n\treturn Promise._new(debug.traceback(nil, 2), function(_, reject)\r\n\t\treject(unpack(values, 1, length))\r\n\tend)\r\nend\r\n\r\n--[[\r\n\tRuns a non-promise-returning function as a Promise with the\r\n  given arguments.\r\n]]\r\nfunction Promise._try(traceback, callback, ...)\r\n\tlocal valuesLength, values = pack(...)\r\n\r\n\treturn Promise._new(traceback, function(resolve)\r\n\t\tresolve(callback(unpack(values, 1, valuesLength)))\r\n\tend)\r\nend\r\n\r\n--[=[\r\n\tBegins a Promise chain, calling a function and returning a Promise resolving with its return value. If the function errors, the returned Promise will be rejected with the error. You can safely yield within the Promise.try callback.\r\n\r\n\t:::info\r\n\t`Promise.try` is similar to [Promise.promisify](#promisify), except the callback is invoked immediately instead of returning a new function.\r\n\t:::\r\n\r\n\t```lua\r\n\tPromise.try(function()\r\n\t\treturn math.random(1, 2) == 1 and \"ok\" or error(\"Oh an error!\")\r\n\tend)\r\n\t\t:andThen(function(text)\r\n\t\t\tprint(text)\r\n\t\tend)\r\n\t\t:catch(function(err)\r\n\t\t\twarn(\"Something went wrong\")\r\n\t\tend)\r\n\t```\r\n\r\n\t@param callback (...: any) -> ...any\r\n\t@return Promise\r\n]=]\r\nfunction Promise.try(...)\r\n\treturn Promise._try(debug.traceback(nil, 2), ...)\r\nend\r\n\r\n--[[\r\n\tReturns a new promise that:\r\n\t\t* is resolved when all input promises resolve\r\n\t\t* is rejected if ANY input promises reject\r\n]]\r\nfunction Promise._all(traceback, promises, amount)\r\n\tif type(promises) ~= \"table\" then\r\n\t\terror(string.format(ERROR_NON_LIST, \"Promise.all\"), 3)\r\n\tend\r\n\r\n\t-- We need to check that each value is a promise here so that we can produce\r\n\t-- a proper error rather than a rejected promise with our error.\r\n\tfor i, promise in pairs(promises) do\r\n\t\tif not Promise.is(promise) then\r\n\t\t\terror(string.format(ERROR_NON_PROMISE_IN_LIST, \"Promise.all\", tostring(i)), 3)\r\n\t\tend\r\n\tend\r\n\r\n\t-- If there are no values then return an already resolved promise.\r\n\tif #promises == 0 or amount == 0 then\r\n\t\treturn Promise.resolve({})\r\n\tend\r\n\r\n\treturn Promise._new(traceback, function(resolve, reject, onCancel)\r\n\t\t-- An array to contain our resolved values from the given promises.\r\n\t\tlocal resolvedValues = {}\r\n\t\tlocal newPromises = {}\r\n\r\n\t\t-- Keep a count of resolved promises because just checking the resolved\r\n\t\t-- values length wouldn't account for promises that resolve with nil.\r\n\t\tlocal resolvedCount = 0\r\n\t\tlocal rejectedCount = 0\r\n\t\tlocal done = false\r\n\r\n\t\tlocal function cancel()\r\n\t\t\tfor _, promise in ipairs(newPromises) do\r\n\t\t\t\tpromise:cancel()\r\n\t\t\tend\r\n\t\tend\r\n\r\n\t\t-- Called when a single value is resolved and resolves if all are done.\r\n\t\tlocal function resolveOne(i, ...)\r\n\t\t\tif done then\r\n\t\t\t\treturn\r\n\t\t\tend\r\n\r\n\t\t\tresolvedCount = resolvedCount + 1\r\n\r\n\t\t\tif amount == nil then\r\n\t\t\t\tresolvedValues[i] = ...\r\n\t\t\telse\r\n\t\t\t\tresolvedValues[resolvedCount] = ...\r\n\t\t\tend\r\n\r\n\t\t\tif resolvedCount >= (amount or #promises) then\r\n\t\t\t\tdone = true\r\n\t\t\t\tresolve(resolvedValues)\r\n\t\t\t\tcancel()\r\n\t\t\tend\r\n\t\tend\r\n\r\n\t\tonCancel(cancel)\r\n\r\n\t\t-- We can assume the values inside `promises` are all promises since we\r\n\t\t-- checked above.\r\n\t\tfor i, promise in ipairs(promises) do\r\n\t\t\tnewPromises[i] = promise:andThen(\r\n\t\t\t\tfunction(...)\r\n\t\t\t\t\tresolveOne(i, ...)\r\n\t\t\t\tend,\r\n\t\t\t\tfunction(...)\r\n\t\t\t\t\trejectedCount = rejectedCount + 1\r\n\r\n\t\t\t\t\tif amount == nil or #promises - rejectedCount < amount then\r\n\t\t\t\t\t\tcancel()\r\n\t\t\t\t\t\tdone = true\r\n\r\n\t\t\t\t\t\treject(...)\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\t)\r\n\t\tend\r\n\r\n\t\tif done then\r\n\t\t\tcancel()\r\n\t\tend\r\n\tend)\r\nend\r\n\r\n--[=[\r\n\tAccepts an array of Promises and returns a new promise that:\r\n\t* is resolved after all input promises resolve.\r\n\t* is rejected if *any* input promises reject.\r\n\r\n\t:::info\r\n\tOnly the first return value from each promise will be present in the resulting array.\r\n\t:::\r\n\r\n\tAfter any input Promise rejects, all other input Promises that are still pending will be cancelled if they have no other consumers.\r\n\r\n\t```lua\r\n\tlocal promises = {\r\n\t\treturnsAPromise(\"example 1\"),\r\n\t\treturnsAPromise(\"example 2\"),\r\n\t\treturnsAPromise(\"example 3\"),\r\n\t}\r\n\r\n\treturn Promise.all(promises)\r\n\t```\r\n\r\n\t@param promises {Promise<T>}\r\n\t@return Promise<{T}>\r\n]=]\r\nfunction Promise.all(promises)\r\n\treturn Promise._all(debug.traceback(nil, 2), promises)\r\nend\r\n\r\n--[=[\r\n\tFolds an array of values or promises into a single value. The array is traversed sequentially.\r\n\r\n\tThe reducer function can return a promise or value directly. Each iteration receives the resolved value from the previous, and the first receives your defined initial value.\r\n\r\n\tThe folding will stop at the first rejection encountered.\r\n\t```lua\r\n\tlocal basket = {\"blueberry\", \"melon\", \"pear\", \"melon\"}\r\n\tPromise.fold(basket, function(cost, fruit)\r\n\t\tif fruit == \"blueberry\" then\r\n\t\t\treturn cost -- blueberries are free!\r\n\t\telse\r\n\t\t\t-- call a function that returns a promise with the fruit price\r\n\t\t\treturn fetchPrice(fruit):andThen(function(fruitCost)\r\n\t\t\t\treturn cost + fruitCost\r\n\t\t\tend)\r\n\t\tend\r\n\tend, 0)\r\n\t```\r\n\r\n\t@since v3.1.0\r\n\t@param list {T | Promise<T>}\r\n\t@param reducer (accumulator: U, value: T, index: number) -> U | Promise<U>\r\n\t@param initialValue U\r\n]=]\r\nfunction Promise.fold(list, callback, initialValue)\r\n\tassert(type(list) == \"table\", \"Bad argument #1 to Promise.fold: must be a table\")\r\n\tassert(type(callback) == \"function\", \"Bad argument #2 to Promise.fold: must be a function\")\r\n\r\n\tlocal accumulator = Promise.resolve(initialValue)\r\n\treturn Promise.each(list, function(resolvedElement, i)\r\n\t\taccumulator = accumulator:andThen(function(previousValueResolved)\r\n\t\t\treturn callback(previousValueResolved, resolvedElement, i)\r\n\t\tend)\r\n\tend):andThenReturn(accumulator)\r\nend\r\n\r\n--[=[\r\n\tAccepts an array of Promises and returns a Promise that is resolved as soon as `count` Promises are resolved from the input array. The resolved array values are in the order that the Promises resolved in. When this Promise resolves, all other pending Promises are cancelled if they have no other consumers.\r\n\r\n\t`count` 0 results in an empty array. The resultant array will never have more than `count` elements.\r\n\r\n\t```lua\r\n\tlocal promises = {\r\n\t\treturnsAPromise(\"example 1\"),\r\n\t\treturnsAPromise(\"example 2\"),\r\n\t\treturnsAPromise(\"example 3\"),\r\n\t}\r\n\r\n\treturn Promise.some(promises, 2) -- Only resolves with first 2 promises to resolve\r\n\t```\r\n\r\n\t@param promises {Promise<T>}\r\n\t@param count number\r\n\t@return Promise<{T}>\r\n]=]\r\nfunction Promise.some(promises, amount)\r\n\tassert(type(amount) == \"number\", \"Bad argument #2 to Promise.some: must be a number\")\r\n\r\n\treturn Promise._all(debug.traceback(nil, 2), promises, amount)\r\nend\r\n\r\n--[=[\r\n\tAccepts an array of Promises and returns a Promise that is resolved as soon as *any* of the input Promises resolves. It will reject only if *all* input Promises reject. As soon as one Promises resolves, all other pending Promises are cancelled if they have no other consumers.\r\n\r\n\tResolves directly with the value of the first resolved Promise. This is essentially [[Promise.some]] with `1` count, except the Promise resolves with the value directly instead of an array with one element.\r\n\r\n\t```lua\r\n\tlocal promises = {\r\n\t\treturnsAPromise(\"example 1\"),\r\n\t\treturnsAPromise(\"example 2\"),\r\n\t\treturnsAPromise(\"example 3\"),\r\n\t}\r\n\r\n\treturn Promise.any(promises) -- Resolves with first value to resolve (only rejects if all 3 rejected)\r\n\t```\r\n\r\n\t@param promises {Promise<T>}\r\n\t@return Promise<T>\r\n]=]\r\nfunction Promise.any(promises)\r\n\treturn Promise._all(debug.traceback(nil, 2), promises, 1):andThen(function(values)\r\n\t\treturn values[1]\r\n\tend)\r\nend\r\n\r\n--[=[\r\n\tAccepts an array of Promises and returns a new Promise that resolves with an array of in-place Statuses when all input Promises have settled. This is equivalent to mapping `promise:finally` over the array of Promises.\r\n\r\n\t```lua\r\n\tlocal promises = {\r\n\t\treturnsAPromise(\"example 1\"),\r\n\t\treturnsAPromise(\"example 2\"),\r\n\t\treturnsAPromise(\"example 3\"),\r\n\t}\r\n\r\n\treturn Promise.allSettled(promises)\r\n\t```\r\n\r\n\t@param promises {Promise<T>}\r\n\t@return Promise<{Status}>\r\n]=]\r\nfunction Promise.allSettled(promises)\r\n\tif type(promises) ~= \"table\" then\r\n\t\terror(string.format(ERROR_NON_LIST, \"Promise.allSettled\"), 2)\r\n\tend\r\n\r\n\t-- We need to check that each value is a promise here so that we can produce\r\n\t-- a proper error rather than a rejected promise with our error.\r\n\tfor i, promise in pairs(promises) do\r\n\t\tif not Promise.is(promise) then\r\n\t\t\terror(string.format(ERROR_NON_PROMISE_IN_LIST, \"Promise.allSettled\", tostring(i)), 2)\r\n\t\tend\r\n\tend\r\n\r\n\t-- If there are no values then return an already resolved promise.\r\n\tif #promises == 0 then\r\n\t\treturn Promise.resolve({})\r\n\tend\r\n\r\n\treturn Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)\r\n\t\t-- An array to contain our resolved values from the given promises.\r\n\t\tlocal fates = {}\r\n\t\tlocal newPromises = {}\r\n\r\n\t\t-- Keep a count of resolved promises because just checking the resolved\r\n\t\t-- values length wouldn't account for promises that resolve with nil.\r\n\t\tlocal finishedCount = 0\r\n\r\n\t\t-- Called when a single value is resolved and resolves if all are done.\r\n\t\tlocal function resolveOne(i, ...)\r\n\t\t\tfinishedCount = finishedCount + 1\r\n\r\n\t\t\tfates[i] = ...\r\n\r\n\t\t\tif finishedCount >= #promises then\r\n\t\t\t\tresolve(fates)\r\n\t\t\tend\r\n\t\tend\r\n\r\n\t\tonCancel(function()\r\n\t\t\tfor _, promise in ipairs(newPromises) do\r\n\t\t\t\tpromise:cancel()\r\n\t\t\tend\r\n\t\tend)\r\n\r\n\t\t-- We can assume the values inside `promises` are all promises since we\r\n\t\t-- checked above.\r\n\t\tfor i, promise in ipairs(promises) do\r\n\t\t\tnewPromises[i] = promise:finally(\r\n\t\t\t\tfunction(...)\r\n\t\t\t\t\tresolveOne(i, ...)\r\n\t\t\t\tend\r\n\t\t\t)\r\n\t\tend\r\n\tend)\r\nend\r\n\r\n--[=[\r\n\tAccepts an array of Promises and returns a new promise that is resolved or rejected as soon as any Promise in the array resolves or rejects.\r\n\r\n\t:::warning\r\n\tIf the first Promise to settle from the array settles with a rejection, the resulting Promise from `race` will reject.\r\n\r\n\tIf you instead want to tolerate rejections, and only care about at least one Promise resolving, you should use [Promise.any](#any) or [Promise.some](#some) instead.\r\n\t:::\r\n\r\n\tAll other Promises that don't win the race will be cancelled if they have no other consumers.\r\n\r\n\t```lua\r\n\tlocal promises = {\r\n\t\treturnsAPromise(\"example 1\"),\r\n\t\treturnsAPromise(\"example 2\"),\r\n\t\treturnsAPromise(\"example 3\"),\r\n\t}\r\n\r\n\treturn Promise.race(promises) -- Only returns 1st value to resolve or reject\r\n\t```\r\n\r\n\t@param promises: {Promise<T>}\r\n\t@return Promise<T>\r\n]=]\r\nfunction Promise.race(promises)\r\n\tassert(type(promises) == \"table\", string.format(ERROR_NON_LIST, \"Promise.race\"))\r\n\r\n\tfor i, promise in pairs(promises) do\r\n\t\tassert(Promise.is(promise), string.format(ERROR_NON_PROMISE_IN_LIST, \"Promise.race\", tostring(i)))\r\n\tend\r\n\r\n\treturn Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)\r\n\t\tlocal newPromises = {}\r\n\t\tlocal finished = false\r\n\r\n\t\tlocal function cancel()\r\n\t\t\tfor _, promise in ipairs(newPromises) do\r\n\t\t\t\tpromise:cancel()\r\n\t\t\tend\r\n\t\tend\r\n\r\n\t\tlocal function finalize(callback)\r\n\t\t\treturn function (...)\r\n\t\t\t\tcancel()\r\n\t\t\t\tfinished = true\r\n\t\t\t\treturn callback(...)\r\n\t\t\tend\r\n\t\tend\r\n\r\n\t\tif onCancel(finalize(reject)) then\r\n\t\t\treturn\r\n\t\tend\r\n\r\n\t\tfor i, promise in ipairs(promises) do\r\n\t\t\tnewPromises[i] = promise:andThen(finalize(resolve), finalize(reject))\r\n\t\tend\r\n\r\n\t\tif finished then\r\n\t\t\tcancel()\r\n\t\tend\r\n\tend)\r\nend\r\n\r\n--[=[\r\n\tIterates serially over the given an array of values, calling the predicate callback on each value before continuing.\r\n\r\n\tIf the predicate returns a Promise, we wait for that Promise to resolve before moving on to the next item\r\n\tin the array.\r\n\r\n\t:::info\r\n\t`Promise.each` is similar to `Promise.all`, except the Promises are ran in order instead of all at once.\r\n\r\n\tBut because Promises are eager, by the time they are created, they're already running. Thus, we need a way to defer creation of each Promise until a later time.\r\n\r\n\tThe predicate function exists as a way for us to operate on our data instead of creating a new closure for each Promise. If you would prefer, you can pass in an array of functions, and in the predicate, call the function and return its return value.\r\n\t:::\r\n\r\n\t```lua\r\n\tPromise.each({\r\n\t\t\"foo\",\r\n\t\t\"bar\",\r\n\t\t\"baz\",\r\n\t\t\"qux\"\r\n\t}, function(value, index)\r\n\t\treturn Promise.delay(1):andThen(function()\r\n\t\tprint((\"%d) Got %s!\"):format(index, value))\r\n\t\tend)\r\n\tend)\r\n\r\n\t--[[\r\n\t\t(1 second passes)\r\n\t\t> 1) Got foo!\r\n\t\t(1 second passes)\r\n\t\t> 2) Got bar!\r\n\t\t(1 second passes)\r\n\t\t> 3) Got baz!\r\n\t\t(1 second passes)\r\n\t\t> 4) Got qux!\r\n\t]]\r\n\t```\r\n\r\n\tIf the Promise a predicate returns rejects, the Promise from `Promise.each` is also rejected with the same value.\r\n\r\n\tIf the array of values contains a Promise, when we get to that point in the list, we wait for the Promise to resolve before calling the predicate with the value.\r\n\r\n\tIf a Promise in the array of values is already Rejected when `Promise.each` is called, `Promise.each` rejects with that value immediately (the predicate callback will never be called even once). If a Promise in the list is already Cancelled when `Promise.each` is called, `Promise.each` rejects with `Promise.Error(Promise.Error.Kind.AlreadyCancelled`). If a Promise in the array of values is Started at first, but later rejects, `Promise.each` will reject with that value and iteration will not continue once iteration encounters that value.\r\n\r\n\tReturns a Promise containing an array of the returned/resolved values from the predicate for each item in the array of values.\r\n\r\n\tIf this Promise returned from `Promise.each` rejects or is cancelled for any reason, the following are true:\r\n\t- Iteration will not continue.\r\n\t- Any Promises within the array of values will now be cancelled if they have no other consumers.\r\n\t- The Promise returned from the currently active predicate will be cancelled if it hasn't resolved yet.\r\n\r\n\t@since 3.0.0\r\n\t@param list {T | Promise<T>}\r\n\t@param predicate (value: T, index: number) -> U | Promise<U>\r\n\t@return Promise<{U}>\r\n]=]\r\nfunction Promise.each(list, predicate)\r\n\tassert(type(list) == \"table\", string.format(ERROR_NON_LIST, \"Promise.each\"))\r\n\tassert(type(predicate) == \"function\", string.format(ERROR_NON_FUNCTION, \"Promise.each\"))\r\n\r\n\treturn Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)\r\n\t\tlocal results = {}\r\n\t\tlocal promisesToCancel = {}\r\n\r\n\t\tlocal cancelled = false\r\n\r\n\t\tlocal function cancel()\r\n\t\t\tfor _, promiseToCancel in ipairs(promisesToCancel) do\r\n\t\t\t\tpromiseToCancel:cancel()\r\n\t\t\tend\r\n\t\tend\r\n\r\n\t\tonCancel(function()\r\n\t\t\tcancelled = true\r\n\r\n\t\t\tcancel()\r\n\t\tend)\r\n\r\n\t\t-- We need to preprocess the list of values and look for Promises.\r\n\t\t-- If we find some, we must register our andThen calls now, so that those Promises have a consumer\r\n\t\t-- from us registered. If we don't do this, those Promises might get cancelled by something else\r\n\t\t-- before we get to them in the series because it's not possible to tell that we plan to use it\r\n\t\t-- unless we indicate it here.\r\n\r\n\t\tlocal preprocessedList = {}\r\n\r\n\t\tfor index, value in ipairs(list) do\r\n\t\t\tif Promise.is(value) then\r\n\t\t\t\tif value:getStatus() == Promise.Status.Cancelled then\r\n\t\t\t\t\tcancel()\r\n\t\t\t\t\treturn reject(Error.new({\r\n\t\t\t\t\t\terror = \"Promise is cancelled\",\r\n\t\t\t\t\t\tkind = Error.Kind.AlreadyCancelled,\r\n\t\t\t\t\t\tcontext = string.format(\r\n\t\t\t\t\t\t\t\"The Promise that was part of the array at index %d passed into Promise.each was already cancelled when Promise.each began.\\n\\nThat Promise was created at:\\n\\n%s\",\r\n\t\t\t\t\t\t\tindex,\r\n\t\t\t\t\t\t\tvalue._source\r\n\t\t\t\t\t\t),\r\n\t\t\t\t\t}))\r\n\t\t\t\telseif value:getStatus() == Promise.Status.Rejected then\r\n\t\t\t\t\tcancel()\r\n\t\t\t\t\treturn reject(select(2, value:await()))\r\n\t\t\t\tend\r\n\r\n\t\t\t\t-- Chain a new Promise from this one so we only cancel ours\r\n\t\t\t\tlocal ourPromise = value:andThen(function(...)\r\n\t\t\t\t\treturn ...\r\n\t\t\t\tend)\r\n\r\n\t\t\t\ttable.insert(promisesToCancel, ourPromise)\r\n\t\t\t\tpreprocessedList[index] = ourPromise\r\n\t\t\telse\r\n\t\t\t\tpreprocessedList[index] = value\r\n\t\t\tend\r\n\t\tend\r\n\r\n\t\tfor index, value in ipairs(preprocessedList) do\r\n\t\t\tif Promise.is(value) then\r\n\t\t\t\tlocal success\r\n\t\t\t\tsuccess, value = value:await()\r\n\r\n\t\t\t\tif not success then\r\n\t\t\t\t\tcancel()\r\n\t\t\t\t\treturn reject(value)\r\n\t\t\t\tend\r\n\t\t\tend\r\n\r\n\t\t\tif cancelled then\r\n\t\t\t\treturn\r\n\t\t\tend\r\n\r\n\t\t\tlocal predicatePromise = Promise.resolve(predicate(value, index))\r\n\r\n\t\t\ttable.insert(promisesToCancel, predicatePromise)\r\n\r\n\t\t\tlocal success, result = predicatePromise:await()\r\n\r\n\t\t\tif not success then\r\n\t\t\t\tcancel()\r\n\t\t\t\treturn reject(result)\r\n\t\t\tend\r\n\r\n\t\t\tresults[index] = result\r\n\t\tend\r\n\r\n\t\tresolve(results)\r\n\tend)\r\nend\r\n\r\n--[=[\r\n\tChecks whether the given object is a Promise via duck typing. This only checks if the object is a table and has an `andThen` method.\r\n\r\n\t@param object any\r\n\t@return boolean -- `true` if the given `object` is a Promise.\r\n]=]\r\nfunction Promise.is(object)\r\n\tif type(object) ~= \"table\" then\r\n\t\treturn false\r\n\tend\r\n\r\n\tlocal objectMetatable = getmetatable(object)\r\n\r\n\tif objectMetatable == Promise then\r\n\t\t-- The Promise came from this library.\r\n\t\treturn true\r\n\telseif objectMetatable == nil then\r\n\t\t-- No metatable, but we should still chain onto tables with andThen methods\r\n\t\treturn type(object.andThen) == \"function\"\r\n\telseif\r\n\t\ttype(objectMetatable) == \"table\"\r\n\t\tand type(rawget(objectMetatable, \"__index\")) == \"table\"\r\n\t\tand type(rawget(rawget(objectMetatable, \"__index\"), \"andThen\")) == \"function\"\r\n\tthen\r\n\t\t-- Maybe this came from a different or older Promise library.\r\n\t\treturn true\r\n\tend\r\n\r\n\treturn false\r\nend\r\n\r\n--[=[\r\n\tWraps a function that yields into one that returns a Promise.\r\n\r\n\tAny errors that occur while executing the function will be turned into rejections.\r\n\r\n\t:::info\r\n\t`Promise.promisify` is similar to [Promise.try](#try), except the callback is returned as a callable function instead of being invoked immediately.\r\n\t:::\r\n\r\n\t```lua\r\n\tlocal sleep = Promise.promisify(wait)\r\n\r\n\tsleep(1):andThen(print)\r\n\t```\r\n\r\n\t```lua\r\n\tlocal isPlayerInGroup = Promise.promisify(function(player, groupId)\r\n\t\treturn player:IsInGroup(groupId)\r\n\tend)\r\n\t```\r\n\r\n\t@param callback (...: any) -> ...any\r\n\t@return (...: any) -> Promise\r\n]=]\r\nfunction Promise.promisify(callback)\r\n\treturn function(...)\r\n\t\treturn Promise._try(debug.traceback(nil, 2), callback, ...)\r\n\tend\r\nend\r\n\r\n--[=[\r\n\tReturns a Promise that resolves after `seconds` seconds have passed. The Promise resolves with the actual amount of time that was waited.\r\n\r\n\tThis function is **not** a wrapper around `wait`. `Promise.delay` uses a custom scheduler which provides more accurate timing. As an optimization, cancelling this Promise instantly removes the task from the scheduler.\r\n\r\n\t:::warning\r\n\tPassing `NaN`, infinity, or a number less than 1/60 is equivalent to passing 1/60.\r\n\t:::\r\n\r\n\t```lua\r\n\t\tPromise.delay(5):andThenCall(print, \"This prints after 5 seconds\")\r\n\t```\r\n\r\n\t@function delay\r\n\t@within Promise\r\n\t@param seconds number\r\n\t@return Promise<number>\r\n]=]\r\ndo\r\n\t-- uses a sorted doubly linked list (queue) to achieve O(1) remove operations and O(n) for insert\r\n\r\n\t-- the initial node in the linked list\r\n\tlocal first\r\n\tlocal connection\r\n\r\n\tfunction Promise.delay(seconds)\r\n\t\tassert(type(seconds) == \"number\", \"Bad argument #1 to Promise.delay, must be a number.\")\r\n\t\t-- If seconds is -INF, INF, NaN, or less than 1 / 60, assume seconds is 1 / 60.\r\n\t\t-- This mirrors the behavior of wait()\r\n\t\tif not (seconds >= 1 / 60) or seconds == math.huge then\r\n\t\t\tseconds = 1 / 60\r\n\t\tend\r\n\r\n\t\treturn Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)\r\n\t\t\tlocal startTime = Promise._getTime()\r\n\t\t\tlocal endTime = startTime + seconds\r\n\r\n\t\t\tlocal node = {\r\n\t\t\t\tresolve = resolve,\r\n\t\t\t\tstartTime = startTime,\r\n\t\t\t\tendTime = endTime,\r\n\t\t\t}\r\n\r\n\t\t\tif connection == nil then -- first is nil when connection is nil\r\n\t\t\t\tfirst = node\r\n\t\t\t\tconnection = Promise._timeEvent:Connect(function()\r\n\t\t\t\t\tlocal threadStart = Promise._getTime()\r\n\r\n\t\t\t\t\twhile first ~= nil and first.endTime < threadStart do\r\n\t\t\t\t\t\tlocal current = first\r\n\t\t\t\t\t\tfirst = current.next\r\n\r\n\t\t\t\t\t\tif first == nil then\r\n\t\t\t\t\t\t\tconnection:Disconnect()\r\n\t\t\t\t\t\t\tconnection = nil\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tfirst.previous = nil\r\n\t\t\t\t\t\tend\r\n\r\n\t\t\t\t\t\tcurrent.resolve(Promise._getTime() - current.startTime)\r\n\t\t\t\t\tend\r\n\t\t\t\tend)\r\n\t\t\telse -- first is non-nil\r\n\t\t\t\tif first.endTime < endTime then -- if `node` should be placed after `first`\r\n\t\t\t\t\t-- we will insert `node` between `current` and `next`\r\n\t\t\t\t\t-- (i.e. after `current` if `next` is nil)\r\n\t\t\t\t\tlocal current = first\r\n\t\t\t\t\tlocal next = current.next\r\n\r\n\t\t\t\t\twhile next ~= nil and next.endTime < endTime do\r\n\t\t\t\t\t\tcurrent = next\r\n\t\t\t\t\t\tnext = current.next\r\n\t\t\t\t\tend\r\n\r\n\t\t\t\t\t-- `current` must be non-nil, but `next` could be `nil` (i.e. last item in list)\r\n\t\t\t\t\tcurrent.next = node\r\n\t\t\t\t\tnode.previous = current\r\n\r\n\t\t\t\t\tif next ~= nil then\r\n\t\t\t\t\t\tnode.next = next\r\n\t\t\t\t\t\tnext.previous = node\r\n\t\t\t\t\tend\r\n\t\t\t\telse\r\n\t\t\t\t\t-- set `node` to `first`\r\n\t\t\t\t\tnode.next = first\r\n\t\t\t\t\tfirst.previous = node\r\n\t\t\t\t\tfirst = node\r\n\t\t\t\tend\r\n\t\t\tend\r\n\r\n\t\t\tonCancel(function()\r\n\t\t\t\t-- remove node from queue\r\n\t\t\t\tlocal next = node.next\r\n\r\n\t\t\t\tif first == node then\r\n\t\t\t\t\tif next == nil then -- if `node` is the first and last\r\n\t\t\t\t\t\tconnection:Disconnect()\r\n\t\t\t\t\t\tconnection = nil\r\n\t\t\t\t\telse -- if `node` is `first` and not the last\r\n\t\t\t\t\t\tnext.previous = nil\r\n\t\t\t\t\tend\r\n\t\t\t\t\tfirst = next\r\n\t\t\t\telse\r\n\t\t\t\t\tlocal previous = node.previous\r\n\t\t\t\t\t-- since `node` is not `first`, then we know `previous` is non-nil\r\n\t\t\t\t\tprevious.next = next\r\n\r\n\t\t\t\t\tif next ~= nil then\r\n\t\t\t\t\t\tnext.previous = previous\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\tend)\r\n\t\tend)\r\n\tend\r\nend\r\n\r\n--[=[\r\n\tReturns a new Promise that resolves if the chained Promise resolves within `seconds` seconds, or rejects if execution time exceeds `seconds`. The chained Promise will be cancelled if the timeout is reached.\r\n\r\n\tRejects with `rejectionValue` if it is non-nil. If a `rejectionValue` is not given, it will reject with a `Promise.Error(Promise.Error.Kind.TimedOut)`. This can be checked with [[Error.isKind]].\r\n\r\n\t```lua\r\n\tgetSomething():timeout(5):andThen(function(something)\r\n\t\t-- got something and it only took at max 5 seconds\r\n\tend):catch(function(e)\r\n\t\t-- Either getting something failed or the time was exceeded.\r\n\r\n\t\tif Promise.Error.isKind(e, Promise.Error.Kind.TimedOut) then\r\n\t\t\twarn(\"Operation timed out!\")\r\n\t\telse\r\n\t\t\twarn(\"Operation encountered an error!\")\r\n\t\tend\r\n\tend)\r\n\t```\r\n\r\n\tSugar for:\r\n\r\n\t```lua\r\n\tPromise.race({\r\n\t\tPromise.delay(seconds):andThen(function()\r\n\t\t\treturn Promise.reject(\r\n\t\t\t\trejectionValue == nil\r\n\t\t\t\tand Promise.Error.new({ kind = Promise.Error.Kind.TimedOut })\r\n\t\t\t\tor rejectionValue\r\n\t\t\t)\r\n\t\tend),\r\n\t\tpromise\r\n\t})\r\n\t```\r\n\r\n\t@param seconds number\r\n\t@param rejectionValue? any -- The value to reject with if the timeout is reached\r\n\t@return Promise\r\n]=]\r\nfunction Promise.prototype:timeout(seconds, rejectionValue)\r\n\tlocal traceback = debug.traceback(nil, 2)\r\n\r\n\treturn Promise.race({\r\n\t\tPromise.delay(seconds):andThen(function()\r\n\t\t\treturn Promise.reject(rejectionValue == nil and Error.new({\r\n\t\t\t\tkind = Error.Kind.TimedOut,\r\n\t\t\t\terror = \"Timed out\",\r\n\t\t\t\tcontext = string.format(\r\n\t\t\t\t\t\"Timeout of %d seconds exceeded.\\n:timeout() called at:\\n\\n%s\",\r\n\t\t\t\t\tseconds,\r\n\t\t\t\t\ttraceback\r\n\t\t\t\t),\r\n\t\t\t}) or rejectionValue)\r\n\t\tend),\r\n\t\tself,\r\n\t})\r\nend\r\n\r\n--[=[\r\n\tReturns the current Promise status.\r\n\r\n\t@return Status\r\n]=]\r\nfunction Promise.prototype:getStatus()\r\n\treturn self._status\r\nend\r\n\r\n--[[\r\n\tCreates a new promise that receives the result of this promise.\r\n\r\n\tThe given callbacks are invoked depending on that result.\r\n]]\r\nfunction Promise.prototype:_andThen(traceback, successHandler, failureHandler)\r\n\tself._unhandledRejection = false\r\n\r\n\t-- Create a new promise to follow this part of the chain\r\n\treturn Promise._new(traceback, function(resolve, reject)\r\n\t\t-- Our default callbacks just pass values onto the next promise.\r\n\t\t-- This lets success and failure cascade correctly!\r\n\r\n\t\tlocal successCallback = resolve\r\n\t\tif successHandler then\r\n\t\t\tsuccessCallback = createAdvancer(\r\n\t\t\t\ttraceback,\r\n\t\t\t\tsuccessHandler,\r\n\t\t\t\tresolve,\r\n\t\t\t\treject\r\n\t\t\t)\r\n\t\tend\r\n\r\n\t\tlocal failureCallback = reject\r\n\t\tif failureHandler then\r\n\t\t\tfailureCallback = createAdvancer(\r\n\t\t\t\ttraceback,\r\n\t\t\t\tfailureHandler,\r\n\t\t\t\tresolve,\r\n\t\t\t\treject\r\n\t\t\t)\r\n\t\tend\r\n\r\n\t\tif self._status == Promise.Status.Started then\r\n\t\t\t-- If we haven't resolved yet, put ourselves into the queue\r\n\t\t\ttable.insert(self._queuedResolve, successCallback)\r\n\t\t\ttable.insert(self._queuedReject, failureCallback)\r\n\t\telseif self._status == Promise.Status.Resolved then\r\n\t\t\t-- This promise has already resolved! Trigger success immediately.\r\n\t\t\tsuccessCallback(unpack(self._values, 1, self._valuesLength))\r\n\t\telseif self._status == Promise.Status.Rejected then\r\n\t\t\t-- This promise died a terrible death! Trigger failure immediately.\r\n\t\t\tfailureCallback(unpack(self._values, 1, self._valuesLength))\r\n\t\telseif self._status == Promise.Status.Cancelled then\r\n\t\t\t-- We don't want to call the success handler or the failure handler,\r\n\t\t\t-- we just reject this promise outright.\r\n\t\t\treject(Error.new({\r\n\t\t\t\terror = \"Promise is cancelled\",\r\n\t\t\t\tkind = Error.Kind.AlreadyCancelled,\r\n\t\t\t\tcontext = \"Promise created at\\n\\n\" .. traceback,\r\n\t\t\t}))\r\n\t\tend\r\n\tend, self)\r\nend\r\n\r\n--[=[\r\n\tChains onto an existing Promise and returns a new Promise.\r\n\r\n\t:::warning\r\n\tWithin the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.\r\n\t:::\r\n\r\n\tReturn a Promise from the success or failure handler and it will be chained onto.\r\n\r\n\t@param successHandler (...: any) -> ...any\r\n\t@param failureHandler? (...: any) -> ...any\r\n\t@return Promise<...any>\r\n]=]\r\nfunction Promise.prototype:andThen(successHandler, failureHandler)\r\n\tassert(\r\n\t\tsuccessHandler == nil or type(successHandler) == \"function\",\r\n\t\tstring.format(ERROR_NON_FUNCTION, \"Promise:andThen\")\r\n\t)\r\n\tassert(\r\n\t\tfailureHandler == nil or type(failureHandler) == \"function\",\r\n\t\tstring.format(ERROR_NON_FUNCTION, \"Promise:andThen\")\r\n\t)\r\n\r\n\treturn self:_andThen(debug.traceback(nil, 2), successHandler, failureHandler)\r\nend\r\n\r\n--[=[\r\n\tShorthand for `Promise:andThen(nil, failureHandler)`.\r\n\r\n\tReturns a Promise that resolves if the `failureHandler` worked without encountering an additional error.\r\n\r\n\t:::warning\r\n\tWithin the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.\r\n\t:::\r\n\r\n\r\n\t@param failureHandler (...: any) -> ...any\r\n\t@return Promise<...any>\r\n]=]\r\nfunction Promise.prototype:catch(failureCallback)\r\n\tassert(\r\n\t\tfailureCallback == nil or type(failureCallback) == \"function\",\r\n\t\tstring.format(ERROR_NON_FUNCTION, \"Promise:catch\")\r\n\t)\r\n\treturn self:_andThen(debug.traceback(nil, 2), nil, failureCallback)\r\nend\r\n\r\n--[=[\r\n\tSimilar to [Promise.andThen](#andThen), except the return value is the same as the value passed to the handler. In other words, you can insert a `:tap` into a Promise chain without affecting the value that downstream Promises receive.\r\n\r\n\t```lua\r\n\t\tgetTheValue()\r\n\t\t:tap(print)\r\n\t\t:andThen(function(theValue)\r\n\t\t\tprint(\"Got\", theValue, \"even though print returns nil!\")\r\n\t\tend)\r\n\t```\r\n\r\n\tIf you return a Promise from the tap handler callback, its value will be discarded but `tap` will still wait until it resolves before passing the original value through.\r\n\r\n\t@param tapHandler (...: any) -> ...any\r\n\t@return Promise<...any>\r\n]=]\r\nfunction Promise.prototype:tap(tapCallback)\r\n\tassert(type(tapCallback) == \"function\", string.format(ERROR_NON_FUNCTION, \"Promise:tap\"))\r\n\treturn self:_andThen(debug.traceback(nil, 2), function(...)\r\n\t\tlocal callbackReturn = tapCallback(...)\r\n\r\n\t\tif Promise.is(callbackReturn) then\r\n\t\t\tlocal length, values = pack(...)\r\n\t\t\treturn callbackReturn:andThen(function()\r\n\t\t\t\treturn unpack(values, 1, length)\r\n\t\t\tend)\r\n\t\tend\r\n\r\n\t\treturn ...\r\n\tend)\r\nend\r\n\r\n--[=[\r\n\tAttaches an `andThen` handler to this Promise that calls the given callback with the predefined arguments. The resolved value is discarded.\r\n\r\n\t```lua\r\n\t\tpromise:andThenCall(someFunction, \"some\", \"arguments\")\r\n\t```\r\n\r\n\tThis is sugar for\r\n\r\n\t```lua\r\n\t\tpromise:andThen(function()\r\n\t\treturn someFunction(\"some\", \"arguments\")\r\n\t\tend)\r\n\t```\r\n\r\n\t@param callback (...: any) -> any\r\n\t@param ...? any -- Additional arguments which will be passed to `callback`\r\n\t@return Promise\r\n]=]\r\nfunction Promise.prototype:andThenCall(callback, ...)\r\n\tassert(type(callback) == \"function\", string.format(ERROR_NON_FUNCTION, \"Promise:andThenCall\"))\r\n\tlocal length, values = pack(...)\r\n\treturn self:_andThen(debug.traceback(nil, 2), function()\r\n\t\treturn callback(unpack(values, 1, length))\r\n\tend)\r\nend\r\n\r\n--[=[\r\n\tAttaches an `andThen` handler to this Promise that discards the resolved value and returns the given value from it.\r\n\r\n\t```lua\r\n\t\tpromise:andThenReturn(\"some\", \"values\")\r\n\t```\r\n\r\n\tThis is sugar for\r\n\r\n\t```lua\r\n\t\tpromise:andThen(function()\r\n\t\t\treturn \"some\", \"values\"\r\n\t\tend)\r\n\t```\r\n\r\n\t:::caution\r\n\tPromises are eager, so if you pass a Promise to `andThenReturn`, it will begin executing before `andThenReturn` is reached in the chain. Likewise, if you pass a Promise created from [[Promise.reject]] into `andThenReturn`, it's possible that this will trigger the unhandled rejection warning. If you need to return a Promise, it's usually best practice to use [[Promise.andThen]].\r\n\t:::\r\n\r\n\t@param ... any -- Values to return from the function\r\n\t@return Promise\r\n]=]\r\nfunction Promise.prototype:andThenReturn(...)\r\n\tlocal length, values = pack(...)\r\n\treturn self:_andThen(debug.traceback(nil, 2), function()\r\n\t\treturn unpack(values, 1, length)\r\n\tend)\r\nend\r\n\r\n--[=[\r\n\tCancels this promise, preventing the promise from resolving or rejecting. Does not do anything if the promise is already settled.\r\n\r\n\tCancellations will propagate upwards and downwards through chained promises.\r\n\r\n\tPromises will only be cancelled if all of their consumers are also cancelled. This is to say that if you call `andThen` twice on the same promise, and you cancel only one of the child promises, it will not cancel the parent promise until the other child promise is also cancelled.\r\n\r\n\t```lua\r\n\t\tpromise:cancel()\r\n\t```\r\n]=]\r\nfunction Promise.prototype:cancel()\r\n\tif self._status ~= Promise.Status.Started then\r\n\t\treturn\r\n\tend\r\n\r\n\tself._status = Promise.Status.Cancelled\r\n\r\n\tif self._cancellationHook then\r\n\t\tself._cancellationHook()\r\n\tend\r\n\r\n\tif self._parent then\r\n\t\tself._parent:_consumerCancelled(self)\r\n\tend\r\n\r\n\tfor child in pairs(self._consumers) do\r\n\t\tchild:cancel()\r\n\tend\r\n\r\n\tself:_finalize()\r\nend\r\n\r\n--[[\r\n\tUsed to decrease the number of consumers by 1, and if there are no more,\r\n\tcancel this promise.\r\n]]\r\nfunction Promise.prototype:_consumerCancelled(consumer)\r\n\tif self._status ~= Promise.Status.Started then\r\n\t\treturn\r\n\tend\r\n\r\n\tself._consumers[consumer] = nil\r\n\r\n\tif next(self._consumers) == nil then\r\n\t\tself:cancel()\r\n\tend\r\nend\r\n\r\n--[[\r\n\tUsed to set a handler for when the promise resolves, rejects, or is\r\n\tcancelled. Returns a new promise chained from this promise.\r\n]]\r\nfunction Promise.prototype:_finally(traceback, finallyHandler, onlyOk)\r\n\tif not onlyOk then\r\n\t\tself._unhandledRejection = false\r\n\tend\r\n\r\n\t-- Return a promise chained off of this promise\r\n\treturn Promise._new(traceback, function(resolve, reject)\r\n\t\tlocal finallyCallback = resolve\r\n\t\tif finallyHandler then\r\n\t\t\tfinallyCallback = createAdvancer(\r\n\t\t\t\ttraceback,\r\n\t\t\t\tfinallyHandler,\r\n\t\t\t\tresolve,\r\n\t\t\t\treject\r\n\t\t\t)\r\n\t\tend\r\n\r\n\t\tif onlyOk then\r\n\t\t\tlocal callback = finallyCallback\r\n\t\t\tfinallyCallback = function(...)\r\n\t\t\t\tif self._status == Promise.Status.Rejected then\r\n\t\t\t\t\treturn resolve(self)\r\n\t\t\t\tend\r\n\r\n\t\t\t\treturn callback(...)\r\n\t\t\tend\r\n\t\tend\r\n\r\n\t\tif self._status == Promise.Status.Started then\r\n\t\t\t-- The promise is not settled, so queue this.\r\n\t\t\ttable.insert(self._queuedFinally, finallyCallback)\r\n\t\telse\r\n\t\t\t-- The promise already settled or was cancelled, run the callback now.\r\n\t\t\tfinallyCallback(self._status)\r\n\t\tend\r\n\tend, self)\r\nend\r\n\r\n--[=[\r\n\tSet a handler that will be called regardless of the promise's fate. The handler is called when the promise is resolved, rejected, *or* cancelled.\r\n\r\n\tReturns a new promise chained from this promise.\r\n\r\n\t:::caution\r\n\tIf the Promise is cancelled, any Promises chained off of it with `andThen` won't run. Only Promises chained with `finally` or `done` will run in the case of cancellation.\r\n\t:::\r\n\r\n\t```lua\r\n\tlocal thing = createSomething()\r\n\r\n\tdoSomethingWith(thing)\r\n\t\t:andThen(function()\r\n\t\t\tprint(\"It worked!\")\r\n\t\t\t-- do something..\r\n\t\tend)\r\n\t\t:catch(function()\r\n\t\t\twarn(\"Oh no it failed!\")\r\n\t\tend)\r\n\t\t:finally(function()\r\n\t\t\t-- either way, destroy thing\r\n\r\n\t\t\tthing:Destroy()\r\n\t\tend)\r\n\r\n\t```\r\n\r\n\t@param finallyHandler (status: Status) -> ...any\r\n\t@return Promise<...any>\r\n]=]\r\nfunction Promise.prototype:finally(finallyHandler)\r\n\tassert(\r\n\t\tfinallyHandler == nil or type(finallyHandler) == \"function\",\r\n\t\tstring.format(ERROR_NON_FUNCTION, \"Promise:finally\")\r\n\t)\r\n\treturn self:_finally(debug.traceback(nil, 2), finallyHandler)\r\nend\r\n\r\n--[=[\r\n\tSame as `andThenCall`, except for `finally`.\r\n\r\n\tAttaches a `finally` handler to this Promise that calls the given callback with the predefined arguments.\r\n\r\n\t@param callback (...: any) -> any\r\n\t@param ...? any -- Additional arguments which will be passed to `callback`\r\n\t@return Promise\r\n]=]\r\nfunction Promise.prototype:finallyCall(callback, ...)\r\n\tassert(type(callback) == \"function\", string.format(ERROR_NON_FUNCTION, \"Promise:finallyCall\"))\r\n\tlocal length, values = pack(...)\r\n\treturn self:_finally(debug.traceback(nil, 2), function()\r\n\t\treturn callback(unpack(values, 1, length))\r\n\tend)\r\nend\r\n\r\n--[=[\r\n\tAttaches a `finally` handler to this Promise that discards the resolved value and returns the given value from it.\r\n\r\n\t```lua\r\n\t\tpromise:finallyReturn(\"some\", \"values\")\r\n\t```\r\n\r\n\tThis is sugar for\r\n\r\n\t```lua\r\n\t\tpromise:finally(function()\r\n\t\t\treturn \"some\", \"values\"\r\n\t\tend)\r\n\t```\r\n\r\n\t@param ... any -- Values to return from the function\r\n\t@return Promise\r\n]=]\r\nfunction Promise.prototype:finallyReturn(...)\r\n\tlocal length, values = pack(...)\r\n\treturn self:_finally(debug.traceback(nil, 2), function()\r\n\t\treturn unpack(values, 1, length)\r\n\tend)\r\nend\r\n\r\n--[=[\r\n\tSet a handler that will be called only if the Promise resolves or is cancelled. This method is similar to `finally`, except it doesn't catch rejections.\r\n\r\n\t:::caution\r\n\t`done` should be reserved specifically when you want to perform some operation after the Promise is finished (like `finally`), but you don't want to consume rejections (like in <a href=\"/roblox-lua-promise/lib/Examples.html#cancellable-animation-sequence\">this example</a>). You should use `andThen` instead if you only care about the Resolved case.\r\n\t:::\r\n\r\n\t:::warning\r\n\tLike `finally`, if the Promise is cancelled, any Promises chained off of it with `andThen` won't run. Only Promises chained with `done` and `finally` will run in the case of cancellation.\r\n\t:::\r\n\r\n\tReturns a new promise chained from this promise.\r\n\r\n\t@param doneHandler (status: Status) -> ...any\r\n\t@return Promise<...any>\r\n]=]\r\nfunction Promise.prototype:done(finallyHandler)\r\n\tassert(\r\n\t\tfinallyHandler == nil or type(finallyHandler) == \"function\",\r\n\t\tstring.format(ERROR_NON_FUNCTION, \"Promise:done\")\r\n\t)\r\n\treturn self:_finally(debug.traceback(nil, 2), finallyHandler, true)\r\nend\r\n\r\n--[=[\r\n\tSame as `andThenCall`, except for `done`.\r\n\r\n\tAttaches a `done` handler to this Promise that calls the given callback with the predefined arguments.\r\n\r\n\t@param callback (...: any) -> any\r\n\t@param ...? any -- Additional arguments which will be passed to `callback`\r\n\t@return Promise\r\n]=]\r\nfunction Promise.prototype:doneCall(callback, ...)\r\n\tassert(type(callback) == \"function\", string.format(ERROR_NON_FUNCTION, \"Promise:doneCall\"))\r\n\tlocal length, values = pack(...)\r\n\treturn self:_finally(debug.traceback(nil, 2), function()\r\n\t\treturn callback(unpack(values, 1, length))\r\n\tend, true)\r\nend\r\n\r\n--[=[\r\n\tAttaches a `done` handler to this Promise that discards the resolved value and returns the given value from it.\r\n\r\n\t```lua\r\n\t\tpromise:doneReturn(\"some\", \"values\")\r\n\t```\r\n\r\n\tThis is sugar for\r\n\r\n\t```lua\r\n\t\tpromise:done(function()\r\n\t\t\treturn \"some\", \"values\"\r\n\t\tend)\r\n\t```\r\n\r\n\t@param ... any -- Values to return from the function\r\n\t@return Promise\r\n]=]\r\nfunction Promise.prototype:doneReturn(...)\r\n\tlocal length, values = pack(...)\r\n\treturn self:_finally(debug.traceback(nil, 2), function()\r\n\t\treturn unpack(values, 1, length)\r\n\tend, true)\r\nend\r\n\r\n--[=[\r\n\tYields the current thread until the given Promise completes. Returns the Promise's status, followed by the values that the promise resolved or rejected with.\r\n\r\n\t@yields\r\n\t@return Status -- The Status representing the fate of the Promise\r\n\t@return ...any -- The values the Promise resolved or rejected with.\r\n]=]\r\nfunction Promise.prototype:awaitStatus()\r\n\tself._unhandledRejection = false\r\n\r\n\tif self._status == Promise.Status.Started then\r\n\t\tlocal bindable = Instance.new(\"BindableEvent\")\r\n\r\n\t\tself:finally(function()\r\n\t\t\tbindable:Fire()\r\n\t\tend)\r\n\r\n\t\tbindable.Event:Wait()\r\n\t\tbindable:Destroy()\r\n\tend\r\n\r\n\tif self._status == Promise.Status.Resolved then\r\n\t\treturn self._status, unpack(self._values, 1, self._valuesLength)\r\n\telseif self._status == Promise.Status.Rejected then\r\n\t\treturn self._status, unpack(self._values, 1, self._valuesLength)\r\n\tend\r\n\r\n\treturn self._status\r\nend\r\n\r\nlocal function awaitHelper(status, ...)\r\n\treturn status == Promise.Status.Resolved, ...\r\nend\r\n\r\n--[=[\r\n\tYields the current thread until the given Promise completes. Returns true if the Promise resolved, followed by the values that the promise resolved or rejected with.\r\n\r\n\t:::caution\r\n\tIf the Promise gets cancelled, this function will return `false`, which is indistinguishable from a rejection. If you need to differentiate, you should use [[Promise.awaitStatus]] instead.\r\n\t:::\r\n\r\n\t```lua\r\n\t\tlocal worked, value = getTheValue():await()\r\n\r\n\tif worked then\r\n\t\tprint(\"got\", value)\r\n\telse\r\n\t\twarn(\"it failed\")\r\n\tend\r\n\t```\r\n\r\n\t@yields\r\n\t@return boolean -- `true` if the Promise successfully resolved\r\n\t@return ...any -- The values the Promise resolved or rejected with.\r\n]=]\r\nfunction Promise.prototype:await()\r\n\treturn awaitHelper(self:awaitStatus())\r\nend\r\n\r\nlocal function expectHelper(status, ...)\r\n\tif status ~= Promise.Status.Resolved then\r\n\t\terror((...) == nil and \"Expected Promise rejected with no value.\" or (...), 3)\r\n\tend\r\n\r\n\treturn ...\r\nend\r\n\r\n--[=[\r\n\tYields the current thread until the given Promise completes. Returns the the values that the promise resolved with.\r\n\r\n\t```lua\r\n\tlocal worked = pcall(function()\r\n\t\tprint(\"got\", getTheValue():expect())\r\n\tend)\r\n\r\n\tif not worked then\r\n\t\twarn(\"it failed\")\r\n\tend\r\n\t```\r\n\r\n\tThis is essentially sugar for:\r\n\r\n\t```lua\r\n\tselect(2, assert(promise:await()))\r\n\t```\r\n\r\n\t**Errors** if the Promise rejects or gets cancelled.\r\n\r\n\t@error any -- Errors with the rejection value if this Promise rejects or gets cancelled.\r\n\t@yields\r\n\t@return ...any -- The values the Promise resolved with.\r\n]=]\r\nfunction Promise.prototype:expect()\r\n\treturn expectHelper(self:awaitStatus())\r\nend\r\n\r\n-- Backwards compatibility\r\nPromise.prototype.awaitValue = Promise.prototype.expect\r\n\r\n--[[\r\n\tIntended for use in tests.\r\n\r\n\tSimilar to await(), but instead of yielding if the promise is unresolved,\r\n\t_unwrap will throw. This indicates an assumption that a promise has\r\n\tresolved.\r\n]]\r\nfunction Promise.prototype:_unwrap()\r\n\tif self._status == Promise.Status.Started then\r\n\t\terror(\"Promise has not resolved or rejected.\", 2)\r\n\tend\r\n\r\n\tlocal success = self._status == Promise.Status.Resolved\r\n\r\n\treturn success, unpack(self._values, 1, self._valuesLength)\r\nend\r\n\r\nfunction Promise.prototype:_resolve(...)\r\n\tif self._status ~= Promise.Status.Started then\r\n\t\tif Promise.is((...)) then\r\n\t\t\t(...):_consumerCancelled(self)\r\n\t\tend\r\n\t\treturn\r\n\tend\r\n\r\n\t-- If the resolved value was a Promise, we chain onto it!\r\n\tif Promise.is((...)) then\r\n\t\t-- Without this warning, arguments sometimes mysteriously disappear\r\n\t\tif select(\"#\", ...) > 1 then\r\n\t\t\tlocal message = string.format(\r\n\t\t\t\t\"When returning a Promise from andThen, extra arguments are \" ..\r\n\t\t\t\t\"discarded! See:\\n\\n%s\",\r\n\t\t\t\tself._source\r\n\t\t\t)\r\n\t\t\twarn(message)\r\n\t\tend\r\n\r\n\t\tlocal chainedPromise = ...\r\n\r\n\t\tlocal promise = chainedPromise:andThen(\r\n\t\t\tfunction(...)\r\n\t\t\t\tself:_resolve(...)\r\n\t\t\tend,\r\n\t\t\tfunction(...)\r\n\t\t\t\tlocal maybeRuntimeError = chainedPromise._values[1]\r\n\r\n\t\t\t\t-- Backwards compatibility < v2\r\n\t\t\t\tif chainedPromise._error then\r\n\t\t\t\t\tmaybeRuntimeError = Error.new({\r\n\t\t\t\t\t\terror = chainedPromise._error,\r\n\t\t\t\t\t\tkind = Error.Kind.ExecutionError,\r\n\t\t\t\t\t\tcontext = \"[No stack trace available as this Promise originated from an older version of the Promise library (< v2)]\",\r\n\t\t\t\t\t})\r\n\t\t\t\tend\r\n\r\n\t\t\t\tif Error.isKind(maybeRuntimeError, Error.Kind.ExecutionError) then\r\n\t\t\t\t\treturn self:_reject(maybeRuntimeError:extend({\r\n\t\t\t\t\t\terror = \"This Promise was chained to a Promise that errored.\",\r\n\t\t\t\t\t\ttrace = \"\",\r\n\t\t\t\t\t\tcontext = string.format(\r\n\t\t\t\t\t\t\t\"The Promise at:\\n\\n%s\\n...Rejected because it was chained to the following Promise, which encountered an error:\\n\",\r\n\t\t\t\t\t\t\tself._source\r\n\t\t\t\t\t\t),\r\n\t\t\t\t\t}))\r\n\t\t\t\tend\r\n\r\n\t\t\t\tself:_reject(...)\r\n\t\t\tend\r\n\t\t)\r\n\r\n\t\tif promise._status == Promise.Status.Cancelled then\r\n\t\t\tself:cancel()\r\n\t\telseif promise._status == Promise.Status.Started then\r\n\t\t\t-- Adopt ourselves into promise for cancellation propagation.\r\n\t\t\tself._parent = promise\r\n\t\t\tpromise._consumers[self] = true\r\n\t\tend\r\n\r\n\t\treturn\r\n\tend\r\n\r\n\tself._status = Promise.Status.Resolved\r\n\tself._valuesLength, self._values = pack(...)\r\n\r\n\t-- We assume that these callbacks will not throw errors.\r\n\tfor _, callback in ipairs(self._queuedResolve) do\r\n\t\tcoroutine.wrap(callback)(...)\r\n\tend\r\n\r\n\tself:_finalize()\r\nend\r\n\r\nfunction Promise.prototype:_reject(...)\r\n\tif self._status ~= Promise.Status.Started then\r\n\t\treturn\r\n\tend\r\n\r\n\tself._status = Promise.Status.Rejected\r\n\tself._valuesLength, self._values = pack(...)\r\n\r\n\t-- If there are any rejection handlers, call those!\r\n\tif not isEmpty(self._queuedReject) then\r\n\t\t-- We assume that these callbacks will not throw errors.\r\n\t\tfor _, callback in ipairs(self._queuedReject) do\r\n\t\t\tcoroutine.wrap(callback)(...)\r\n\t\tend\r\n\telse\r\n\t\t-- At this point, no one was able to observe the error.\r\n\t\t-- An error handler might still be attached if the error occurred\r\n\t\t-- synchronously. We'll wait one tick, and if there are still no\r\n\t\t-- observers, then we should put a message in the console.\r\n\r\n\t\tlocal err = tostring((...))\r\n\r\n\t\tcoroutine.wrap(function()\r\n\t\t\tPromise._timeEvent:Wait()\r\n\r\n\t\t\t-- Someone observed the error, hooray!\r\n\t\t\tif not self._unhandledRejection then\r\n\t\t\t\treturn\r\n\t\t\tend\r\n\r\n\t\t\t-- Build a reasonable message\r\n\t\t\tlocal message = string.format(\r\n\t\t\t\t\"Unhandled Promise rejection:\\n\\n%s\\n\\n%s\",\r\n\t\t\t\terr,\r\n\t\t\t\tself._source\r\n\t\t\t)\r\n\r\n\t\t\tif Promise.TEST then\r\n\t\t\t\t-- Don't spam output when we're running tests.\r\n\t\t\t\treturn\r\n\t\t\tend\r\n\r\n\t\t\twarn(message)\r\n\t\tend)()\r\n\tend\r\n\r\n\tself:_finalize()\r\nend\r\n\r\n--[[\r\n\tCalls any :finally handlers. We need this to be a separate method and\r\n\tqueue because we must call all of the finally callbacks upon a success,\r\n\tfailure, *and* cancellation.\r\n]]\r\nfunction Promise.prototype:_finalize()\r\n\tfor _, callback in ipairs(self._queuedFinally) do\r\n\t\t-- Purposefully not passing values to callbacks here, as it could be the\r\n\t\t-- resolved values, or rejected errors. If the developer needs the values,\r\n\t\t-- they should use :andThen or :catch explicitly.\r\n\t\tcoroutine.wrap(callback)(self._status)\r\n\tend\r\n\r\n\tself._queuedFinally = nil\r\n\tself._queuedReject = nil\r\n\tself._queuedResolve = nil\r\n\r\n\t-- Clear references to other Promises to allow gc\r\n\tif not Promise.TEST then\r\n\t\tself._parent = nil\r\n\t\tself._consumers = nil\r\n\tend\r\nend\r\n\r\n--[=[\r\n\tChains a Promise from this one that is resolved if this Promise is already resolved, and rejected if it is not resolved at the time of calling `:now()`. This can be used to ensure your `andThen` handler occurs on the same frame as the root Promise execution.\r\n\r\n\t```lua\r\n\tdoSomething()\r\n\t\t:now()\r\n\t\t:andThen(function(value)\r\n\t\t\tprint(\"Got\", value, \"synchronously.\")\r\n\t\tend)\r\n\t```\r\n\r\n\tIf this Promise is still running, Rejected, or Cancelled, the Promise returned from `:now()` will reject with the `rejectionValue` if passed, otherwise with a `Promise.Error(Promise.Error.Kind.NotResolvedInTime)`. This can be checked with [[Error.isKind]].\r\n\r\n\t@param rejectionValue? any -- The value to reject with if the Promise isn't resolved\r\n\t@return Promise\r\n]=]\r\nfunction Promise.prototype:now(rejectionValue)\r\n\tlocal traceback = debug.traceback(nil, 2)\r\n\tif self._status == Promise.Status.Resolved then\r\n\t\treturn self:_andThen(traceback, function(...)\r\n\t\t\treturn ...\r\n\t\tend)\r\n\telse\r\n\t\treturn Promise.reject(rejectionValue == nil and Error.new({\r\n\t\t\tkind = Error.Kind.NotResolvedInTime,\r\n\t\t\terror = \"This Promise was not resolved in time for :now()\",\r\n\t\t\tcontext = \":now() was called at:\\n\\n\" .. traceback,\r\n\t\t}) or rejectionValue)\r\n\tend\r\nend\r\n\r\n--[=[\r\n\tRepeatedly calls a Promise-returning function up to `times` number of times, until the returned Promise resolves.\r\n\r\n\tIf the amount of retries is exceeded, the function will return the latest rejected Promise.\r\n\r\n\t```lua\r\n\tlocal function canFail(a, b, c)\r\n\t\treturn Promise.new(function(resolve, reject)\r\n\t\t\t-- do something that can fail\r\n\r\n\t\t\tlocal failed, thing = doSomethingThatCanFail(a, b, c)\r\n\r\n\t\t\tif failed then\r\n\t\t\t\treject(\"it failed\")\r\n\t\t\telse\r\n\t\t\t\tresolve(thing)\r\n\t\t\tend\r\n\t\tend)\r\n\tend\r\n\r\n\tlocal MAX_RETRIES = 10\r\n\tlocal value = Promise.retry(canFail, MAX_RETRIES, \"foo\", \"bar\", \"baz\") -- args to send to canFail\r\n\t```\r\n\r\n\t@since 3.0.0\r\n\t@param callback (...: P) -> Promise<T>\r\n\t@param times number\r\n\t@param ...? P\r\n]=]\r\nfunction Promise.retry(callback, times, ...)\r\n\tassert(type(callback) == \"function\", \"Parameter #1 to Promise.retry must be a function\")\r\n\tassert(type(times) == \"number\", \"Parameter #2 to Promise.retry must be a number\")\r\n\r\n\tlocal args, length = {...}, select(\"#\", ...)\r\n\r\n\treturn Promise.resolve(callback(...)):catch(function(...)\r\n\t\tif times > 0 then\r\n\t\t\treturn Promise.retry(callback, times - 1, unpack(args, 1, length))\r\n\t\telse\r\n\t\t\treturn Promise.reject(...)\r\n\t\tend\r\n\tend)\r\nend\r\n\r\n--[=[\r\n\tConverts an event into a Promise which resolves the next time the event fires.\r\n\r\n\tThe optional `predicate` callback, if passed, will receive the event arguments and should return `true` or `false`, based on if this fired event should resolve the Promise or not. If `true`, the Promise resolves. If `false`, nothing happens and the predicate will be rerun the next time the event fires.\r\n\r\n\tThe Promise will resolve with the event arguments.\r\n\r\n\t:::tip\r\n\tThis function will work given any object with a `Connect` method. This includes all Roblox events.\r\n\t:::\r\n\r\n\t```lua\r\n\t-- Creates a Promise which only resolves when `somePart` is touched\r\n\t-- by a part named `\"Something specific\"`.\r\n\treturn Promise.fromEvent(somePart.Touched, function(part)\r\n\t\treturn part.Name == \"Something specific\"\r\n\tend)\r\n\t```\r\n\r\n\t@since 3.0.0\r\n\t@param event Event -- Any object with a `Connect` method. This includes all Roblox events.\r\n\t@param predicate? (...: P) -> boolean -- A function which determines if the Promise should resolve with the given value, or wait for the next event to check again.\r\n\t@return Promise<P>\r\n]=]\r\nfunction Promise.fromEvent(event, predicate)\r\n\tpredicate = predicate or function()\r\n\t\treturn true\r\n\tend\r\n\r\n\treturn Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)\r\n\t\tlocal connection\r\n\t\tlocal shouldDisconnect = false\r\n\r\n\t\tlocal function disconnect()\r\n\t\t\tconnection:Disconnect()\r\n\t\t\tconnection = nil\r\n\t\tend\r\n\r\n\t\t-- We use shouldDisconnect because if the callback given to Connect is called before\r\n\t\t-- Connect returns, connection will still be nil. This happens with events that queue up\r\n\t\t-- events when there's nothing connected, such as RemoteEvents\r\n\r\n\t\tconnection = event:Connect(function(...)\r\n\t\t\tlocal callbackValue = predicate(...)\r\n\r\n\t\t\tif callbackValue == true then\r\n\t\t\t\tresolve(...)\r\n\r\n\t\t\t\tif connection then\r\n\t\t\t\t\tdisconnect()\r\n\t\t\t\telse\r\n\t\t\t\t\tshouldDisconnect = true\r\n\t\t\t\tend\r\n\t\t\telseif type(callbackValue) ~= \"boolean\" then\r\n\t\t\t\terror(\"Promise.fromEvent predicate should always return a boolean\")\r\n\t\t\tend\r\n\t\tend)\r\n\r\n\t\tif shouldDisconnect and connection then\r\n\t\t\treturn disconnect()\r\n\t\tend\r\n\r\n\t\tonCancel(disconnect)\r\n\tend)\r\nend\r\n\r\nreturn Promise\r\n"}},"Children":["6957f7983ac08acabf224266f365d3f7"],"Metadata":{"ignoreUnknownInstances":false}},"133a9b005fbea6beac1d059ddc9fef0e":{"Id":"133a9b005fbea6beac1d059ddc9fef0e","Parent":"d539d2b3547c9166dae5ffd367a37cb3","Name":"ContextBlock","ClassName":"ModuleScript","Properties":{"Source":{"String":"local t = require(script.Parent.Parent.Parent.t)\n\nlocal IContext = require(script.Parent.IContext)\ntype IContext = IContext.IContext\n\nlocal isContextBlock = t.interface({\n\tRemote = t.instanceIsA(\"RemoteEvent\"),\n\tContext = t.any,\n\tActions = t.interface({\n\t\t[t.string] = t.interface({ t.callback }),\n\t}),\n})\n\nexport type ContextBlock = {\n\tRemote: RemoteEvent,\n\tContext: IContext,\n\tActions: {\n\t\t[string]: { () -> () },\n\t},\n}\n\nreturn function(obj)\n\treturn isContextBlock(obj) :: boolean\nend\n"}},"Children":[],"Metadata":{"ignoreUnknownInstances":false}},"99ea57650081417fd256b7092ccdba19":{"Id":"99ea57650081417fd256b7092ccdba19","Parent":"c39e26776de082e6222fc839fa8b1b48","Name":"ts","ClassName":"ModuleScript","Properties":{"Source":{"String":"-- t: a runtime typechecker for Roblox\r\n\r\n-- regular lua compatibility\r\nlocal typeof = typeof or type\r\n\r\nlocal function primitive(typeName)\r\n\treturn function(value)\r\n\t\tlocal valueType = typeof(value)\r\n\t\tif valueType == typeName then\r\n\t\t\treturn true\r\n\t\telse\r\n\t\t\treturn false\r\n\t\tend\r\n\tend\r\nend\r\n\r\nlocal t = {}\r\n\r\n--[[**\r\n\tmatches any type except nil\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nfunction t.any(value)\r\n\tif value ~= nil then\r\n\t\treturn true\r\n\telse\r\n\t\treturn false\r\n\tend\r\nend\r\n\r\n--Lua primitives\r\n\r\n--[[**\r\n\tensures Lua primitive boolean type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.boolean = primitive(\"boolean\")\r\n\r\n--[[**\r\n\tensures Lua primitive thread type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.thread = primitive(\"thread\")\r\n\r\n--[[**\r\n\tensures Lua primitive callback type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.callback = primitive(\"function\")\r\nt[\"function\"] = t.callback\r\n\r\n--[[**\r\n\tensures Lua primitive none type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.none = primitive(\"nil\")\r\nt[\"nil\"] = t.none\r\n\r\n--[[**\r\n\tensures Lua primitive string type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.string = primitive(\"string\")\r\n\r\n--[[**\r\n\tensures Lua primitive table type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.table = primitive(\"table\")\r\n\r\n--[[**\r\n\tensures Lua primitive userdata type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.userdata = primitive(\"userdata\")\r\n\r\n--[[**\r\n\tensures value is a number and non-NaN\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nfunction t.number(value)\r\n\tlocal valueType = typeof(value)\r\n\tif valueType == \"number\" then\r\n\t\tif value == value then\r\n\t\t\treturn true\r\n\t\telse\r\n\t\t\treturn false\r\n\t\tend\r\n\telse\r\n\t\treturn false\r\n\tend\r\nend\r\n\r\n--[[**\r\n\tensures value is NaN\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nfunction t.nan(value)\r\n\tlocal valueType = typeof(value)\r\n\tif valueType == \"number\" then\r\n\t\tif value ~= value then\r\n\t\t\treturn true\r\n\t\telse\r\n\t\t\treturn false\r\n\t\tend\r\n\telse\r\n\t\treturn false\r\n\tend\r\nend\r\n\r\n-- roblox types\r\n\r\n--[[**\r\n\tensures Roblox Axes type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.Axes = primitive(\"Axes\")\r\n\r\n--[[**\r\n\tensures Roblox BrickColor type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.BrickColor = primitive(\"BrickColor\")\r\n\r\n--[[**\r\n\tensures Roblox CFrame type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.CFrame = primitive(\"CFrame\")\r\n\r\n--[[**\r\n\tensures Roblox Color3 type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.Color3 = primitive(\"Color3\")\r\n\r\n--[[**\r\n\tensures Roblox ColorSequence type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.ColorSequence = primitive(\"ColorSequence\")\r\n\r\n--[[**\r\n\tensures Roblox ColorSequenceKeypoint type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.ColorSequenceKeypoint = primitive(\"ColorSequenceKeypoint\")\r\n\r\n--[[**\r\n\tensures Roblox DockWidgetPluginGuiInfo type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.DockWidgetPluginGuiInfo = primitive(\"DockWidgetPluginGuiInfo\")\r\n\r\n--[[**\r\n\tensures Roblox Faces type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.Faces = primitive(\"Faces\")\r\n\r\n--[[**\r\n\tensures Roblox Instance type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.Instance = primitive(\"Instance\")\r\n\r\n--[[**\r\n\tensures Roblox NumberRange type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.NumberRange = primitive(\"NumberRange\")\r\n\r\n--[[**\r\n\tensures Roblox NumberSequence type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.NumberSequence = primitive(\"NumberSequence\")\r\n\r\n--[[**\r\n\tensures Roblox NumberSequenceKeypoint type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.NumberSequenceKeypoint = primitive(\"NumberSequenceKeypoint\")\r\n\r\n--[[**\r\n\tensures Roblox PathWaypoint type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.PathWaypoint = primitive(\"PathWaypoint\")\r\n\r\n--[[**\r\n\tensures Roblox PhysicalProperties type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.PhysicalProperties = primitive(\"PhysicalProperties\")\r\n\r\n--[[**\r\n\tensures Roblox Random type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.Random = primitive(\"Random\")\r\n\r\n--[[**\r\n\tensures Roblox Ray type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.Ray = primitive(\"Ray\")\r\n\r\n--[[**\r\n\tensures Roblox Rect type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.Rect = primitive(\"Rect\")\r\n\r\n--[[**\r\n\tensures Roblox Region3 type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.Region3 = primitive(\"Region3\")\r\n\r\n--[[**\r\n\tensures Roblox Region3int16 type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.Region3int16 = primitive(\"Region3int16\")\r\n\r\n--[[**\r\n\tensures Roblox TweenInfo type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.TweenInfo = primitive(\"TweenInfo\")\r\n\r\n--[[**\r\n\tensures Roblox UDim type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.UDim = primitive(\"UDim\")\r\n\r\n--[[**\r\n\tensures Roblox UDim2 type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.UDim2 = primitive(\"UDim2\")\r\n\r\n--[[**\r\n\tensures Roblox Vector2 type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.Vector2 = primitive(\"Vector2\")\r\n\r\n--[[**\r\n\tensures Roblox Vector3 type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.Vector3 = primitive(\"Vector3\")\r\n\r\n--[[**\r\n\tensures Roblox Vector3int16 type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.Vector3int16 = primitive(\"Vector3int16\")\r\n\r\n-- roblox enum types\r\n\r\n--[[**\r\n\tensures Roblox Enum type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.Enum = primitive(\"Enum\")\r\n\r\n--[[**\r\n\tensures Roblox EnumItem type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.EnumItem = primitive(\"EnumItem\")\r\n\r\n--[[**\r\n\tensures Roblox RBXScriptSignal type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.RBXScriptSignal = primitive(\"RBXScriptSignal\")\r\n\r\n--[[**\r\n\tensures Roblox RBXScriptConnection type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.RBXScriptConnection = primitive(\"RBXScriptConnection\")\r\n\r\n--[[**\r\n\tensures value is a given literal value\r\n\r\n\t@param literal The literal to use\r\n\r\n\t@returns A function that will return true iff the condition is passed\r\n**--]]\r\nfunction t.literal(...)\r\n\tlocal size = select(\"#\", ...)\r\n\tif size == 1 then\r\n\t\tlocal literal = ...\r\n\t\treturn function(value)\r\n\t\t\tif value ~= literal then\r\n\t\t\t\treturn false\r\n\t\t\tend\r\n\r\n\t\t\treturn true\r\n\t\tend\r\n\telse\r\n\t\tlocal literals = {}\r\n\t\tfor i = 1, size do\r\n\t\t\tlocal value = select(i, ...)\r\n\t\t\tliterals[i] = t.literal(value)\r\n\t\tend\r\n\r\n\t\treturn t.union(table.unpack(literals, 1, size))\r\n\tend\r\nend\r\n\r\n--[[**\r\n\tDEPRECATED\r\n\tPlease use t.literal\r\n**--]]\r\nt.exactly = t.literal\r\n\r\n--[[**\r\n\tReturns a t.union of each key in the table as a t.literal\r\n\r\n\t@param keyTable The table to get keys from\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nfunction t.keyOf(keyTable)\r\n\tlocal keys = {}\r\n\tlocal length = 0\r\n\tfor key in pairs(keyTable) do\r\n\t\tlength = length + 1\r\n\t\tkeys[length] = key\r\n\tend\r\n\r\n\treturn t.literal(table.unpack(keys, 1, length))\r\nend\r\n\r\n--[[**\r\n\tReturns a t.union of each value in the table as a t.literal\r\n\r\n\t@param valueTable The table to get values from\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nfunction t.valueOf(valueTable)\r\n\tlocal values = {}\r\n\tlocal length = 0\r\n\tfor _, value in pairs(valueTable) do\r\n\t\tlength = length + 1\r\n\t\tvalues[length] = value\r\n\tend\r\n\r\n\treturn t.literal(table.unpack(values, 1, length))\r\nend\r\n\r\n--[[**\r\n\tensures value is an integer\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nfunction t.integer(value)\r\n\tlocal success = t.number(value)\r\n\tif not success then\r\n\t\treturn false\r\n\tend\r\n\r\n\tif value % 1 == 0 then\r\n\t\treturn true\r\n\telse\r\n\t\treturn false\r\n\tend\r\nend\r\n\r\n--[[**\r\n\tensures value is a number where min <= value\r\n\r\n\t@param min The minimum to use\r\n\r\n\t@returns A function that will return true iff the condition is passed\r\n**--]]\r\nfunction t.numberMin(min)\r\n\treturn function(value)\r\n\t\tlocal success = t.number(value)\r\n\t\tif not success then\r\n\t\t\treturn false\r\n\t\tend\r\n\r\n\t\tif value >= min then\r\n\t\t\treturn true\r\n\t\telse\r\n\t\t\treturn false\r\n\t\tend\r\n\tend\r\nend\r\n\r\n--[[**\r\n\tensures value is a number where value <= max\r\n\r\n\t@param max The maximum to use\r\n\r\n\t@returns A function that will return true iff the condition is passed\r\n**--]]\r\nfunction t.numberMax(max)\r\n\treturn function(value)\r\n\t\tlocal success = t.number(value)\r\n\t\tif not success then\r\n\t\t\treturn false\r\n\t\tend\r\n\r\n\t\tif value <= max then\r\n\t\t\treturn true\r\n\t\telse\r\n\t\t\treturn false\r\n\t\tend\r\n\tend\r\nend\r\n\r\n--[[**\r\n\tensures value is a number where min < value\r\n\r\n\t@param min The minimum to use\r\n\r\n\t@returns A function that will return true iff the condition is passed\r\n**--]]\r\nfunction t.numberMinExclusive(min)\r\n\treturn function(value)\r\n\t\tlocal success = t.number(value)\r\n\t\tif not success then\r\n\t\t\treturn false\r\n\t\tend\r\n\r\n\t\tif min < value then\r\n\t\t\treturn true\r\n\t\telse\r\n\t\t\treturn false\r\n\t\tend\r\n\tend\r\nend\r\n\r\n--[[**\r\n\tensures value is a number where value < max\r\n\r\n\t@param max The maximum to use\r\n\r\n\t@returns A function that will return true iff the condition is passed\r\n**--]]\r\nfunction t.numberMaxExclusive(max)\r\n\treturn function(value)\r\n\t\tlocal success = t.number(value)\r\n\t\tif not success then\r\n\t\t\treturn false\r\n\t\tend\r\n\r\n\t\tif value < max then\r\n\t\t\treturn true\r\n\t\telse\r\n\t\t\treturn false\r\n\t\tend\r\n\tend\r\nend\r\n\r\n--[[**\r\n\tensures value is a number where value > 0\r\n\r\n\t@returns A function that will return true iff the condition is passed\r\n**--]]\r\nt.numberPositive = t.numberMinExclusive(0)\r\n\r\n--[[**\r\n\tensures value is a number where value < 0\r\n\r\n\t@returns A function that will return true iff the condition is passed\r\n**--]]\r\nt.numberNegative = t.numberMaxExclusive(0)\r\n\r\n--[[**\r\n\tensures value is a number where min <= value <= max\r\n\r\n\t@param min The minimum to use\r\n\t@param max The maximum to use\r\n\r\n\t@returns A function that will return true iff the condition is passed\r\n**--]]\r\nfunction t.numberConstrained(min, max)\r\n\tassert(t.number(min))\r\n\tassert(t.number(max))\r\n\tlocal minCheck = t.numberMin(min)\r\n\tlocal maxCheck = t.numberMax(max)\r\n\r\n\treturn function(value)\r\n\t\tlocal minSuccess = minCheck(value)\r\n\t\tif not minSuccess then\r\n\t\t\treturn false\r\n\t\tend\r\n\r\n\t\tlocal maxSuccess = maxCheck(value)\r\n\t\tif not maxSuccess then\r\n\t\t\treturn false\r\n\t\tend\r\n\r\n\t\treturn true\r\n\tend\r\nend\r\n\r\n--[[**\r\n\tensures value is a number where min < value < max\r\n\r\n\t@param min The minimum to use\r\n\t@param max The maximum to use\r\n\r\n\t@returns A function that will return true iff the condition is passed\r\n**--]]\r\nfunction t.numberConstrainedExclusive(min, max)\r\n\tassert(t.number(min))\r\n\tassert(t.number(max))\r\n\tlocal minCheck = t.numberMinExclusive(min)\r\n\tlocal maxCheck = t.numberMaxExclusive(max)\r\n\r\n\treturn function(value)\r\n\t\tlocal minSuccess = minCheck(value)\r\n\t\tif not minSuccess then\r\n\t\t\treturn false\r\n\t\tend\r\n\r\n\t\tlocal maxSuccess = maxCheck(value)\r\n\t\tif not maxSuccess then\r\n\t\t\treturn false\r\n\t\tend\r\n\r\n\t\treturn true\r\n\tend\r\nend\r\n\r\n--[[**\r\n\tensures value matches string pattern\r\n\r\n\t@param string pattern to check against\r\n\r\n\t@returns A function that will return true iff the condition is passed\r\n**--]]\r\nfunction t.match(pattern)\r\n\tassert(t.string(pattern))\r\n\treturn function(value)\r\n\t\tlocal stringSuccess = t.string(value)\r\n\t\tif not stringSuccess then\r\n\t\t\treturn false\r\n\t\tend\r\n\r\n\t\tif string.match(value, pattern) == nil then\r\n\t\t\treturn false\r\n\t\tend\r\n\r\n\t\treturn true\r\n\tend\r\nend\r\n\r\n--[[**\r\n\tensures value is either nil or passes check\r\n\r\n\t@param check The check to use\r\n\r\n\t@returns A function that will return true iff the condition is passed\r\n**--]]\r\nfunction t.optional(check)\r\n\tassert(t.callback(check))\r\n\treturn function(value)\r\n\t\tif value == nil then\r\n\t\t\treturn true\r\n\t\tend\r\n\r\n\t\tlocal success = check(value)\r\n\t\tif success then\r\n\t\t\treturn true\r\n\t\telse\r\n\t\t\treturn false\r\n\t\tend\r\n\tend\r\nend\r\n\r\n--[[**\r\n\tmatches given tuple against tuple type definition\r\n\r\n\t@param ... The type definition for the tuples\r\n\r\n\t@returns A function that will return true iff the condition is passed\r\n**--]]\r\nfunction t.tuple(...)\r\n\tlocal checks = { ... }\r\n\treturn function(...)\r\n\t\tlocal args = { ... }\r\n\t\tfor i, check in ipairs(checks) do\r\n\t\t\tlocal success = check(args[i])\r\n\t\t\tif success == false then\r\n\t\t\t\treturn false\r\n\t\t\tend\r\n\t\tend\r\n\r\n\t\treturn true\r\n\tend\r\nend\r\n\r\n--[[**\r\n\tensures all keys in given table pass check\r\n\r\n\t@param check The function to use to check the keys\r\n\r\n\t@returns A function that will return true iff the condition is passed\r\n**--]]\r\nfunction t.keys(check)\r\n\tassert(t.callback(check))\r\n\treturn function(value)\r\n\t\tlocal tableSuccess = t.table(value)\r\n\t\tif tableSuccess == false then\r\n\t\t\treturn false\r\n\t\tend\r\n\r\n\t\tfor key in pairs(value) do\r\n\t\t\tlocal success = check(key)\r\n\t\t\tif success == false then\r\n\t\t\t\treturn false\r\n\t\t\tend\r\n\t\tend\r\n\r\n\t\treturn true\r\n\tend\r\nend\r\n\r\n--[[**\r\n\tensures all values in given table pass check\r\n\r\n\t@param check The function to use to check the values\r\n\r\n\t@returns A function that will return true iff the condition is passed\r\n**--]]\r\nfunction t.values(check)\r\n\tassert(t.callback(check))\r\n\treturn function(value)\r\n\t\tlocal tableSuccess = t.table(value)\r\n\t\tif tableSuccess == false then\r\n\t\t\treturn false\r\n\t\tend\r\n\r\n\t\tfor _, val in pairs(value) do\r\n\t\t\tlocal success = check(val)\r\n\t\t\tif success == false then\r\n\t\t\t\treturn false\r\n\t\t\tend\r\n\t\tend\r\n\r\n\t\treturn true\r\n\tend\r\nend\r\n\r\n--[[**\r\n\tensures value is a table and all keys pass keyCheck and all values pass valueCheck\r\n\r\n\t@param keyCheck The function to use to check the keys\r\n\t@param valueCheck The function to use to check the values\r\n\r\n\t@returns A function that will return true iff the condition is passed\r\n**--]]\r\nfunction t.map(keyCheck, valueCheck)\r\n\tassert(t.callback(keyCheck))\r\n\tassert(t.callback(valueCheck))\r\n\tlocal keyChecker = t.keys(keyCheck)\r\n\tlocal valueChecker = t.values(valueCheck)\r\n\r\n\treturn function(value)\r\n\t\tlocal keySuccess = keyChecker(value)\r\n\t\tif not keySuccess then\r\n\t\t\treturn false\r\n\t\tend\r\n\r\n\t\tlocal valueSuccess = valueChecker(value)\r\n\t\tif not valueSuccess then\r\n\t\t\treturn false\r\n\t\tend\r\n\r\n\t\treturn true\r\n\tend\r\nend\r\n\r\n--[[**\r\n\tensures value is a table and all keys pass valueCheck and all values are true\r\n\r\n\t@param valueCheck The function to use to check the values\r\n\r\n\t@returns A function that will return true iff the condition is passed\r\n**--]]\r\nfunction t.set(valueCheck)\r\n\treturn t.map(valueCheck, t.literal(true))\r\nend\r\n\r\ndo\r\n\tlocal arrayKeysCheck = t.keys(t.integer)\r\n--[[**\r\n\t\tensures value is an array and all values of the array match check\r\n\r\n\t\t@param check The check to compare all values with\r\n\r\n\t\t@returns A function that will return true iff the condition is passed\r\n\t**--]]\r\n\tfunction t.array(check)\r\n\t\tassert(t.callback(check))\r\n\t\tlocal valuesCheck = t.values(check)\r\n\r\n\t\treturn function(value)\r\n\t\t\tlocal keySuccess = arrayKeysCheck(value)\r\n\t\t\tif keySuccess == false then\r\n\t\t\t\treturn false\r\n\t\t\tend\r\n\r\n\t\t\t-- # is unreliable for sparse arrays\r\n\t\t\t-- Count upwards using ipairs to avoid false positives from the behavior of #\r\n\t\t\tlocal arraySize = 0\r\n\r\n\t\t\tfor _ in ipairs(value) do\r\n\t\t\t\tarraySize = arraySize + 1\r\n\t\t\tend\r\n\r\n\t\t\tfor key in pairs(value) do\r\n\t\t\t\tif key < 1 or key > arraySize then\r\n\t\t\t\t\treturn false\r\n\t\t\t\tend\r\n\t\t\tend\r\n\r\n\t\t\tlocal valueSuccess = valuesCheck(value)\r\n\t\t\tif not valueSuccess then\r\n\t\t\t\treturn false\r\n\t\t\tend\r\n\r\n\t\t\treturn true\r\n\t\tend\r\n\tend\r\n\r\n--[[**\r\n\t\tensures value is an array of a strict makeup and size\r\n\r\n\t\t@param check The check to compare all values with\r\n\r\n\t\t@returns A function that will return true iff the condition is passed\r\n\t**--]]\r\n\tfunction t.strictArray(...)\r\n\t\tlocal valueTypes = { ... }\r\n\t\tassert(t.array(t.callback)(valueTypes))\r\n\r\n\t\treturn function(value)\r\n\t\t\tlocal keySuccess = arrayKeysCheck(value)\r\n\t\t\tif keySuccess == false then\r\n\t\t\t\treturn false\r\n\t\t\tend\r\n\r\n\t\t\t-- If there's more than the set array size, disallow\r\n\t\t\tif #valueTypes < #value then\r\n\t\t\t\treturn false\r\n\t\t\tend\r\n\r\n\t\t\tfor idx, typeFn in pairs(valueTypes) do\r\n\t\t\t\tlocal typeSuccess = typeFn(value[idx])\r\n\t\t\t\tif not typeSuccess then\r\n\t\t\t\t\treturn false\r\n\t\t\t\tend\r\n\t\t\tend\r\n\r\n\t\t\treturn true\r\n\t\tend\r\n\tend\r\nend\r\n\r\ndo\r\n\tlocal callbackArray = t.array(t.callback)\r\n--[[**\r\n\t\tcreates a union type\r\n\r\n\t\t@param ... The checks to union\r\n\r\n\t\t@returns A function that will return true iff the condition is passed\r\n\t**--]]\r\n\tfunction t.union(...)\r\n\t\tlocal checks = { ... }\r\n\t\tassert(callbackArray(checks))\r\n\r\n\t\treturn function(value)\r\n\t\t\tfor _, check in ipairs(checks) do\r\n\t\t\t\tif check(value) then\r\n\t\t\t\t\treturn true\r\n\t\t\t\tend\r\n\t\t\tend\r\n\r\n\t\t\treturn false\r\n\t\tend\r\n\tend\r\n\r\n--[[**\r\n\t\tAlias for t.union\r\n\t**--]]\r\n\tt.some = t.union\r\n\r\n--[[**\r\n\t\tcreates an intersection type\r\n\r\n\t\t@param ... The checks to intersect\r\n\r\n\t\t@returns A function that will return true iff the condition is passed\r\n\t**--]]\r\n\tfunction t.intersection(...)\r\n\t\tlocal checks = { ... }\r\n\t\tassert(callbackArray(checks))\r\n\r\n\t\treturn function(value)\r\n\t\t\tfor _, check in ipairs(checks) do\r\n\t\t\t\tlocal success = check(value)\r\n\t\t\t\tif not success then\r\n\t\t\t\t\treturn false\r\n\t\t\t\tend\r\n\t\t\tend\r\n\r\n\t\t\treturn true\r\n\t\tend\r\n\tend\r\n\r\n--[[**\r\n\t\tAlias for t.intersection\r\n\t**--]]\r\n\tt.every = t.intersection\r\nend\r\n\r\ndo\r\n\tlocal checkInterface = t.map(t.any, t.callback)\r\n--[[**\r\n\t\tensures value matches given interface definition\r\n\r\n\t\t@param checkTable The interface definition\r\n\r\n\t\t@returns A function that will return true iff the condition is passed\r\n\t**--]]\r\n\tfunction t.interface(checkTable)\r\n\t\tassert(checkInterface(checkTable))\r\n\t\treturn function(value)\r\n\t\t\tlocal tableSuccess = t.table(value)\r\n\t\t\tif tableSuccess == false then\r\n\t\t\t\treturn false\r\n\t\t\tend\r\n\r\n\t\t\tfor key, check in pairs(checkTable) do\r\n\t\t\t\tlocal success = check(value[key])\r\n\t\t\t\tif success == false then\r\n\t\t\t\t\treturn false\r\n\t\t\t\tend\r\n\t\t\tend\r\n\r\n\t\t\treturn true\r\n\t\tend\r\n\tend\r\n\r\n--[[**\r\n\t\tensures value matches given interface definition strictly\r\n\r\n\t\t@param checkTable The interface definition\r\n\r\n\t\t@returns A function that will return true iff the condition is passed\r\n\t**--]]\r\n\tfunction t.strictInterface(checkTable)\r\n\t\tassert(checkInterface(checkTable))\r\n\t\treturn function(value)\r\n\t\t\tlocal tableSuccess = t.table(value)\r\n\t\t\tif tableSuccess == false then\r\n\t\t\t\treturn false\r\n\t\t\tend\r\n\r\n\t\t\tfor key, check in pairs(checkTable) do\r\n\t\t\t\tlocal success = check(value[key])\r\n\t\t\t\tif success == false then\r\n\t\t\t\t\treturn false\r\n\t\t\t\tend\r\n\t\t\tend\r\n\r\n\t\t\tfor key in pairs(value) do\r\n\t\t\t\tif not checkTable[key] then\r\n\t\t\t\t\treturn false\r\n\t\t\t\tend\r\n\t\t\tend\r\n\r\n\t\t\treturn true\r\n\t\tend\r\n\tend\r\nend\r\n\r\n--[[**\r\n\tensure value is an Instance and it's ClassName matches the given ClassName\r\n\r\n\t@param className The class name to check for\r\n\r\n\t@returns A function that will return true iff the condition is passed\r\n**--]]\r\nfunction t.instanceOf(className, childTable)\r\n\tassert(t.string(className))\r\n\r\n\tlocal childrenCheck\r\n\tif childTable ~= nil then\r\n\t\tchildrenCheck = t.children(childTable)\r\n\tend\r\n\r\n\treturn function(value)\r\n\t\tlocal instanceSuccess = t.Instance(value)\r\n\t\tif not instanceSuccess then\r\n\t\t\treturn false\r\n\t\tend\r\n\r\n\t\tif value.ClassName ~= className then\r\n\t\t\treturn false\r\n\t\tend\r\n\r\n\t\tif childrenCheck then\r\n\t\t\tlocal childrenSuccess = childrenCheck(value)\r\n\t\t\tif not childrenSuccess then\r\n\t\t\t\treturn false\r\n\t\t\tend\r\n\t\tend\r\n\r\n\t\treturn true\r\n\tend\r\nend\r\n\r\nt.instance = t.instanceOf\r\n\r\n--[[**\r\n\tensure value is an Instance and it's ClassName matches the given ClassName by an IsA comparison\r\n\r\n\t@param className The class name to check for\r\n\r\n\t@returns A function that will return true iff the condition is passed\r\n**--]]\r\nfunction t.instanceIsA(className, childTable)\r\n\tassert(t.string(className))\r\n\r\n\tlocal childrenCheck\r\n\tif childTable ~= nil then\r\n\t\tchildrenCheck = t.children(childTable)\r\n\tend\r\n\r\n\treturn function(value)\r\n\t\tlocal instanceSuccess = t.Instance(value)\r\n\t\tif not instanceSuccess then\r\n\t\t\treturn false\r\n\t\tend\r\n\r\n\t\tif not value:IsA(className) then\r\n\t\t\treturn false\r\n\t\tend\r\n\r\n\t\tif childrenCheck then\r\n\t\t\tlocal childrenSuccess = childrenCheck(value)\r\n\t\t\tif not childrenSuccess then\r\n\t\t\t\treturn false\r\n\t\t\tend\r\n\t\tend\r\n\r\n\t\treturn true\r\n\tend\r\nend\r\n\r\n--[[**\r\n\tensures value is an enum of the correct type\r\n\r\n\t@param enum The enum to check\r\n\r\n\t@returns A function that will return true iff the condition is passed\r\n**--]]\r\nfunction t.enum(enum)\r\n\tassert(t.Enum(enum))\r\n\treturn function(value)\r\n\t\tlocal enumItemSuccess = t.EnumItem(value)\r\n\t\tif not enumItemSuccess then\r\n\t\t\treturn false\r\n\t\tend\r\n\r\n\t\tif value.EnumType == enum then\r\n\t\t\treturn true\r\n\t\telse\r\n\t\t\treturn false\r\n\t\tend\r\n\tend\r\nend\r\n\r\ndo\r\n\tlocal checkWrap = t.tuple(t.callback, t.callback)\r\n\r\n--[[**\r\n\t\twraps a callback in an assert with checkArgs\r\n\r\n\t\t@param callback The function to wrap\r\n\t\t@param checkArgs The functon to use to check arguments in the assert\r\n\r\n\t\t@returns A function that first asserts using checkArgs and then calls callback\r\n\t**--]]\r\n\tfunction t.wrap(callback, checkArgs)\r\n\t\tassert(checkWrap(callback, checkArgs))\r\n\t\treturn function(...)\r\n\t\t\tassert(checkArgs(...))\r\n\t\t\treturn callback(...)\r\n\t\tend\r\n\tend\r\nend\r\n\r\n--[[**\r\n\tasserts a given check\r\n\r\n\t@param check The function to wrap with an assert\r\n\r\n\t@returns A function that simply wraps the given check in an assert\r\n**--]]\r\nfunction t.strict(check)\r\n\treturn function(...)\r\n\t\tassert(check(...))\r\n\tend\r\nend\r\n\r\ndo\r\n\tlocal checkChildren = t.map(t.string, t.callback)\r\n\r\n--[[**\r\n\t\tTakes a table where keys are child names and values are functions to check the children against.\r\n\t\tPass an instance tree into the function.\r\n\t\tIf at least one child passes each check, the overall check passes.\r\n\r\n\t\tWarning! If you pass in a tree with more than one child of the same name, this function will always return false\r\n\r\n\t\t@param checkTable The table to check against\r\n\r\n\t\t@returns A function that checks an instance tree\r\n\t**--]]\r\n\tfunction t.children(checkTable)\r\n\t\tassert(checkChildren(checkTable))\r\n\r\n\t\treturn function(value)\r\n\t\t\tlocal instanceSuccess = t.Instance(value)\r\n\t\t\tif not instanceSuccess then\r\n\t\t\t\treturn false\r\n\t\t\tend\r\n\r\n\t\t\tlocal childrenByName = {}\r\n\t\t\tfor _, child in ipairs(value:GetChildren()) do\r\n\t\t\t\tlocal name = child.Name\r\n\t\t\t\tif checkTable[name] then\r\n\t\t\t\t\tif childrenByName[name] then\r\n\t\t\t\t\t\treturn false\r\n\t\t\t\t\tend\r\n\r\n\t\t\t\t\tchildrenByName[name] = child\r\n\t\t\t\tend\r\n\t\t\tend\r\n\r\n\t\t\tfor name, check in pairs(checkTable) do\r\n\t\t\t\tlocal success = check(childrenByName[name])\r\n\t\t\t\tif not success then\r\n\t\t\t\t\treturn false\r\n\t\t\t\tend\r\n\t\t\tend\r\n\r\n\t\t\treturn true\r\n\t\tend\r\n\tend\r\nend\r\n\r\nreturn { t = t }\r\n"}},"Children":[],"Metadata":{"ignoreUnknownInstances":false}},"c39e26776de082e6222fc839fa8b1b48":{"Id":"c39e26776de082e6222fc839fa8b1b48","Parent":"9ee814837a27b11857e89563135cd306","Name":"t","ClassName":"ModuleScript","Properties":{"Source":{"String":"-- t: a runtime typechecker for Roblox\r\n\r\n-- regular lua compatibility\r\nlocal typeof = typeof or type\r\n\r\nlocal function primitive(typeName)\r\n\treturn function(value)\r\n\t\tlocal valueType = typeof(value)\r\n\t\tif valueType == typeName then\r\n\t\t\treturn true\r\n\t\telse\r\n\t\t\treturn false, string.format(\"%s expected, got %s\", typeName, valueType)\r\n\t\tend\r\n\tend\r\nend\r\n\r\nlocal t = {}\r\n\r\n--[[**\r\n\tmatches any type except nil\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nfunction t.any(value)\r\n\tif value ~= nil then\r\n\t\treturn true\r\n\telse\r\n\t\treturn false, \"any expected, got nil\"\r\n\tend\r\nend\r\n\r\n--Lua primitives\r\n\r\n--[[**\r\n\tensures Lua primitive boolean type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.boolean = primitive(\"boolean\")\r\n\r\n--[[**\r\n\tensures Lua primitive thread type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.thread = primitive(\"thread\")\r\n\r\n--[[**\r\n\tensures Lua primitive callback type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.callback = primitive(\"function\")\r\nt[\"function\"] = t.callback\r\n\r\n--[[**\r\n\tensures Lua primitive none type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.none = primitive(\"nil\")\r\nt[\"nil\"] = t.none\r\n\r\n--[[**\r\n\tensures Lua primitive string type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.string = primitive(\"string\")\r\n\r\n--[[**\r\n\tensures Lua primitive table type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.table = primitive(\"table\")\r\n\r\n--[[**\r\n\tensures Lua primitive userdata type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.userdata = primitive(\"userdata\")\r\n\r\n--[[**\r\n\tensures value is a number and non-NaN\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nfunction t.number(value)\r\n\tlocal valueType = typeof(value)\r\n\tif valueType == \"number\" then\r\n\t\tif value == value then\r\n\t\t\treturn true\r\n\t\telse\r\n\t\t\treturn false, \"unexpected NaN value\"\r\n\t\tend\r\n\telse\r\n\t\treturn false, string.format(\"number expected, got %s\", valueType)\r\n\tend\r\nend\r\n\r\n--[[**\r\n\tensures value is NaN\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nfunction t.nan(value)\r\n\tlocal valueType = typeof(value)\r\n\tif valueType == \"number\" then\r\n\t\tif value ~= value then\r\n\t\t\treturn true\r\n\t\telse\r\n\t\t\treturn false, \"unexpected non-NaN value\"\r\n\t\tend\r\n\telse\r\n\t\treturn false, string.format(\"number expected, got %s\", valueType)\r\n\tend\r\nend\r\n\r\n-- roblox types\r\n\r\n--[[**\r\n\tensures Roblox Axes type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.Axes = primitive(\"Axes\")\r\n\r\n--[[**\r\n\tensures Roblox BrickColor type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.BrickColor = primitive(\"BrickColor\")\r\n\r\n--[[**\r\n\tensures Roblox CFrame type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.CFrame = primitive(\"CFrame\")\r\n\r\n--[[**\r\n\tensures Roblox Color3 type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.Color3 = primitive(\"Color3\")\r\n\r\n--[[**\r\n\tensures Roblox ColorSequence type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.ColorSequence = primitive(\"ColorSequence\")\r\n\r\n--[[**\r\n\tensures Roblox ColorSequenceKeypoint type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.ColorSequenceKeypoint = primitive(\"ColorSequenceKeypoint\")\r\n\r\n--[[**\r\n\tensures Roblox DockWidgetPluginGuiInfo type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.DockWidgetPluginGuiInfo = primitive(\"DockWidgetPluginGuiInfo\")\r\n\r\n--[[**\r\n\tensures Roblox Faces type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.Faces = primitive(\"Faces\")\r\n\r\n--[[**\r\n\tensures Roblox Instance type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.Instance = primitive(\"Instance\")\r\n\r\n--[[**\r\n\tensures Roblox NumberRange type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.NumberRange = primitive(\"NumberRange\")\r\n\r\n--[[**\r\n\tensures Roblox NumberSequence type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.NumberSequence = primitive(\"NumberSequence\")\r\n\r\n--[[**\r\n\tensures Roblox NumberSequenceKeypoint type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.NumberSequenceKeypoint = primitive(\"NumberSequenceKeypoint\")\r\n\r\n--[[**\r\n\tensures Roblox PathWaypoint type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.PathWaypoint = primitive(\"PathWaypoint\")\r\n\r\n--[[**\r\n\tensures Roblox PhysicalProperties type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.PhysicalProperties = primitive(\"PhysicalProperties\")\r\n\r\n--[[**\r\n\tensures Roblox Random type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.Random = primitive(\"Random\")\r\n\r\n--[[**\r\n\tensures Roblox Ray type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.Ray = primitive(\"Ray\")\r\n\r\n--[[**\r\n\tensures Roblox Rect type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.Rect = primitive(\"Rect\")\r\n\r\n--[[**\r\n\tensures Roblox Region3 type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.Region3 = primitive(\"Region3\")\r\n\r\n--[[**\r\n\tensures Roblox Region3int16 type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.Region3int16 = primitive(\"Region3int16\")\r\n\r\n--[[**\r\n\tensures Roblox TweenInfo type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.TweenInfo = primitive(\"TweenInfo\")\r\n\r\n--[[**\r\n\tensures Roblox UDim type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.UDim = primitive(\"UDim\")\r\n\r\n--[[**\r\n\tensures Roblox UDim2 type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.UDim2 = primitive(\"UDim2\")\r\n\r\n--[[**\r\n\tensures Roblox Vector2 type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.Vector2 = primitive(\"Vector2\")\r\n\r\n--[[**\r\n\tensures Roblox Vector3 type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.Vector3 = primitive(\"Vector3\")\r\n\r\n--[[**\r\n\tensures Roblox Vector3int16 type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.Vector3int16 = primitive(\"Vector3int16\")\r\n\r\n-- roblox enum types\r\n\r\n--[[**\r\n\tensures Roblox Enum type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.Enum = primitive(\"Enum\")\r\n\r\n--[[**\r\n\tensures Roblox EnumItem type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.EnumItem = primitive(\"EnumItem\")\r\n\r\n--[[**\r\n\tensures Roblox RBXScriptSignal type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.RBXScriptSignal = primitive(\"RBXScriptSignal\")\r\n\r\n--[[**\r\n\tensures Roblox RBXScriptConnection type\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nt.RBXScriptConnection = primitive(\"RBXScriptConnection\")\r\n\r\n--[[**\r\n\tensures value is a given literal value\r\n\r\n\t@param literal The literal to use\r\n\r\n\t@returns A function that will return true iff the condition is passed\r\n**--]]\r\nfunction t.literal(...)\r\n\tlocal size = select(\"#\", ...)\r\n\tif size == 1 then\r\n\t\tlocal literal = ...\r\n\t\treturn function(value)\r\n\t\t\tif value ~= literal then\r\n\t\t\t\treturn false, string.format(\"expected %s, got %s\", tostring(literal), tostring(value))\r\n\t\t\tend\r\n\r\n\t\t\treturn true\r\n\t\tend\r\n\telse\r\n\t\tlocal literals = {}\r\n\t\tfor i = 1, size do\r\n\t\t\tlocal value = select(i, ...)\r\n\t\t\tliterals[i] = t.literal(value)\r\n\t\tend\r\n\r\n\t\treturn t.union(table.unpack(literals, 1, size))\r\n\tend\r\nend\r\n\r\n--[[**\r\n\tDEPRECATED\r\n\tPlease use t.literal\r\n**--]]\r\nt.exactly = t.literal\r\n\r\n--[[**\r\n\tReturns a t.union of each key in the table as a t.literal\r\n\r\n\t@param keyTable The table to get keys from\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nfunction t.keyOf(keyTable)\r\n\tlocal keys = {}\r\n\tlocal length = 0\r\n\tfor key in pairs(keyTable) do\r\n\t\tlength = length + 1\r\n\t\tkeys[length] = key\r\n\tend\r\n\r\n\treturn t.literal(table.unpack(keys, 1, length))\r\nend\r\n\r\n--[[**\r\n\tReturns a t.union of each value in the table as a t.literal\r\n\r\n\t@param valueTable The table to get values from\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nfunction t.valueOf(valueTable)\r\n\tlocal values = {}\r\n\tlocal length = 0\r\n\tfor _, value in pairs(valueTable) do\r\n\t\tlength = length + 1\r\n\t\tvalues[length] = value\r\n\tend\r\n\r\n\treturn t.literal(table.unpack(values, 1, length))\r\nend\r\n\r\n--[[**\r\n\tensures value is an integer\r\n\r\n\t@param value The value to check against\r\n\r\n\t@returns True iff the condition is satisfied, false otherwise\r\n**--]]\r\nfunction t.integer(value)\r\n\tlocal success, errMsg = t.number(value)\r\n\tif not success then\r\n\t\treturn false, errMsg or \"\"\r\n\tend\r\n\r\n\tif value % 1 == 0 then\r\n\t\treturn true\r\n\telse\r\n\t\treturn false, string.format(\"integer expected, got %s\", value)\r\n\tend\r\nend\r\n\r\n--[[**\r\n\tensures value is a number where min <= value\r\n\r\n\t@param min The minimum to use\r\n\r\n\t@returns A function that will return true iff the condition is passed\r\n**--]]\r\nfunction t.numberMin(min)\r\n\treturn function(value)\r\n\t\tlocal success, errMsg = t.number(value)\r\n\t\tif not success then\r\n\t\t\treturn false, errMsg or \"\"\r\n\t\tend\r\n\r\n\t\tif value >= min then\r\n\t\t\treturn true\r\n\t\telse\r\n\t\t\treturn false, string.format(\"number >= %s expected, got %s\", min, value)\r\n\t\tend\r\n\tend\r\nend\r\n\r\n--[[**\r\n\tensures value is a number where value <= max\r\n\r\n\t@param max The maximum to use\r\n\r\n\t@returns A function that will return true iff the condition is passed\r\n**--]]\r\nfunction t.numberMax(max)\r\n\treturn function(value)\r\n\t\tlocal success, errMsg = t.number(value)\r\n\t\tif not success then\r\n\t\t\treturn false, errMsg\r\n\t\tend\r\n\r\n\t\tif value <= max then\r\n\t\t\treturn true\r\n\t\telse\r\n\t\t\treturn false, string.format(\"number <= %s expected, got %s\", max, value)\r\n\t\tend\r\n\tend\r\nend\r\n\r\n--[[**\r\n\tensures value is a number where min < value\r\n\r\n\t@param min The minimum to use\r\n\r\n\t@returns A function that will return true iff the condition is passed\r\n**--]]\r\nfunction t.numberMinExclusive(min)\r\n\treturn function(value)\r\n\t\tlocal success, errMsg = t.number(value)\r\n\t\tif not success then\r\n\t\t\treturn false, errMsg or \"\"\r\n\t\tend\r\n\r\n\t\tif min < value then\r\n\t\t\treturn true\r\n\t\telse\r\n\t\t\treturn false, string.format(\"number > %s expected, got %s\", min, value)\r\n\t\tend\r\n\tend\r\nend\r\n\r\n--[[**\r\n\tensures value is a number where value < max\r\n\r\n\t@param max The maximum to use\r\n\r\n\t@returns A function that will return true iff the condition is passed\r\n**--]]\r\nfunction t.numberMaxExclusive(max)\r\n\treturn function(value)\r\n\t\tlocal success, errMsg = t.number(value)\r\n\t\tif not success then\r\n\t\t\treturn false, errMsg or \"\"\r\n\t\tend\r\n\r\n\t\tif value < max then\r\n\t\t\treturn true\r\n\t\telse\r\n\t\t\treturn false, string.format(\"number < %s expected, got %s\", max, value)\r\n\t\tend\r\n\tend\r\nend\r\n\r\n--[[**\r\n\tensures value is a number where value > 0\r\n\r\n\t@returns A function that will return true iff the condition is passed\r\n**--]]\r\nt.numberPositive = t.numberMinExclusive(0)\r\n\r\n--[[**\r\n\tensures value is a number where value < 0\r\n\r\n\t@returns A function that will return true iff the condition is passed\r\n**--]]\r\nt.numberNegative = t.numberMaxExclusive(0)\r\n\r\n--[[**\r\n\tensures value is a number where min <= value <= max\r\n\r\n\t@param min The minimum to use\r\n\t@param max The maximum to use\r\n\r\n\t@returns A function that will return true iff the condition is passed\r\n**--]]\r\nfunction t.numberConstrained(min, max)\r\n\tassert(t.number(min))\r\n\tassert(t.number(max))\r\n\tlocal minCheck = t.numberMin(min)\r\n\tlocal maxCheck = t.numberMax(max)\r\n\r\n\treturn function(value)\r\n\t\tlocal minSuccess, minErrMsg = minCheck(value)\r\n\t\tif not minSuccess then\r\n\t\t\treturn false, minErrMsg or \"\"\r\n\t\tend\r\n\r\n\t\tlocal maxSuccess, maxErrMsg = maxCheck(value)\r\n\t\tif not maxSuccess then\r\n\t\t\treturn false, maxErrMsg or \"\"\r\n\t\tend\r\n\r\n\t\treturn true\r\n\tend\r\nend\r\n\r\n--[[**\r\n\tensures value is a number where min < value < max\r\n\r\n\t@param min The minimum to use\r\n\t@param max The maximum to use\r\n\r\n\t@returns A function that will return true iff the condition is passed\r\n**--]]\r\nfunction t.numberConstrainedExclusive(min, max)\r\n\tassert(t.number(min))\r\n\tassert(t.number(max))\r\n\tlocal minCheck = t.numberMinExclusive(min)\r\n\tlocal maxCheck = t.numberMaxExclusive(max)\r\n\r\n\treturn function(value)\r\n\t\tlocal minSuccess, minErrMsg = minCheck(value)\r\n\t\tif not minSuccess then\r\n\t\t\treturn false, minErrMsg or \"\"\r\n\t\tend\r\n\r\n\t\tlocal maxSuccess, maxErrMsg = maxCheck(value)\r\n\t\tif not maxSuccess then\r\n\t\t\treturn false, maxErrMsg or \"\"\r\n\t\tend\r\n\r\n\t\treturn true\r\n\tend\r\nend\r\n\r\n--[[**\r\n\tensures value matches string pattern\r\n\r\n\t@param string pattern to check against\r\n\r\n\t@returns A function that will return true iff the condition is passed\r\n**--]]\r\nfunction t.match(pattern)\r\n\tassert(t.string(pattern))\r\n\treturn function(value)\r\n\t\tlocal stringSuccess, stringErrMsg = t.string(value)\r\n\t\tif not stringSuccess then\r\n\t\t\treturn false, stringErrMsg\r\n\t\tend\r\n\r\n\t\tif string.match(value, pattern) == nil then\r\n\t\t\treturn false, string.format(\"%q failed to match pattern %q\", value, pattern)\r\n\t\tend\r\n\r\n\t\treturn true\r\n\tend\r\nend\r\n\r\n--[[**\r\n\tensures value is either nil or passes check\r\n\r\n\t@param check The check to use\r\n\r\n\t@returns A function that will return true iff the condition is passed\r\n**--]]\r\nfunction t.optional(check)\r\n\tassert(t.callback(check))\r\n\treturn function(value)\r\n\t\tif value == nil then\r\n\t\t\treturn true\r\n\t\tend\r\n\r\n\t\tlocal success, errMsg = check(value)\r\n\t\tif success then\r\n\t\t\treturn true\r\n\t\telse\r\n\t\t\treturn false, string.format(\"(optional) %s\", errMsg or \"\")\r\n\t\tend\r\n\tend\r\nend\r\n\r\n--[[**\r\n\tmatches given tuple against tuple type definition\r\n\r\n\t@param ... The type definition for the tuples\r\n\r\n\t@returns A function that will return true iff the condition is passed\r\n**--]]\r\nfunction t.tuple(...)\r\n\tlocal checks = { ... }\r\n\treturn function(...)\r\n\t\tlocal args = { ... }\r\n\t\tfor i, check in ipairs(checks) do\r\n\t\t\tlocal success, errMsg = check(args[i])\r\n\t\t\tif success == false then\r\n\t\t\t\treturn false, string.format(\"Bad tuple index #%s:\\n\\t%s\", i, errMsg or \"\")\r\n\t\t\tend\r\n\t\tend\r\n\r\n\t\treturn true\r\n\tend\r\nend\r\n\r\n--[[**\r\n\tensures all keys in given table pass check\r\n\r\n\t@param check The function to use to check the keys\r\n\r\n\t@returns A function that will return true iff the condition is passed\r\n**--]]\r\nfunction t.keys(check)\r\n\tassert(t.callback(check))\r\n\treturn function(value)\r\n\t\tlocal tableSuccess, tableErrMsg = t.table(value)\r\n\t\tif tableSuccess == false then\r\n\t\t\treturn false, tableErrMsg or \"\"\r\n\t\tend\r\n\r\n\t\tfor key in pairs(value) do\r\n\t\t\tlocal success, errMsg = check(key)\r\n\t\t\tif success == false then\r\n\t\t\t\treturn false, string.format(\"bad key %s:\\n\\t%s\", tostring(key), errMsg or \"\")\r\n\t\t\tend\r\n\t\tend\r\n\r\n\t\treturn true\r\n\tend\r\nend\r\n\r\n--[[**\r\n\tensures all values in given table pass check\r\n\r\n\t@param check The function to use to check the values\r\n\r\n\t@returns A function that will return true iff the condition is passed\r\n**--]]\r\nfunction t.values(check)\r\n\tassert(t.callback(check))\r\n\treturn function(value)\r\n\t\tlocal tableSuccess, tableErrMsg = t.table(value)\r\n\t\tif tableSuccess == false then\r\n\t\t\treturn false, tableErrMsg or \"\"\r\n\t\tend\r\n\r\n\t\tfor key, val in pairs(value) do\r\n\t\t\tlocal success, errMsg = check(val)\r\n\t\t\tif success == false then\r\n\t\t\t\treturn false, string.format(\"bad value for key %s:\\n\\t%s\", tostring(key), errMsg or \"\")\r\n\t\t\tend\r\n\t\tend\r\n\r\n\t\treturn true\r\n\tend\r\nend\r\n\r\n--[[**\r\n\tensures value is a table and all keys pass keyCheck and all values pass valueCheck\r\n\r\n\t@param keyCheck The function to use to check the keys\r\n\t@param valueCheck The function to use to check the values\r\n\r\n\t@returns A function that will return true iff the condition is passed\r\n**--]]\r\nfunction t.map(keyCheck, valueCheck)\r\n\tassert(t.callback(keyCheck))\r\n\tassert(t.callback(valueCheck))\r\n\tlocal keyChecker = t.keys(keyCheck)\r\n\tlocal valueChecker = t.values(valueCheck)\r\n\r\n\treturn function(value)\r\n\t\tlocal keySuccess, keyErr = keyChecker(value)\r\n\t\tif not keySuccess then\r\n\t\t\treturn false, keyErr or \"\"\r\n\t\tend\r\n\r\n\t\tlocal valueSuccess, valueErr = valueChecker(value)\r\n\t\tif not valueSuccess then\r\n\t\t\treturn false, valueErr or \"\"\r\n\t\tend\r\n\r\n\t\treturn true\r\n\tend\r\nend\r\n\r\n--[[**\r\n\tensures value is a table and all keys pass valueCheck and all values are true\r\n\r\n\t@param valueCheck The function to use to check the values\r\n\r\n\t@returns A function that will return true iff the condition is passed\r\n**--]]\r\nfunction t.set(valueCheck)\r\n\treturn t.map(valueCheck, t.literal(true))\r\nend\r\n\r\ndo\r\n\tlocal arrayKeysCheck = t.keys(t.integer)\r\n--[[**\r\n\t\tensures value is an array and all values of the array match check\r\n\r\n\t\t@param check The check to compare all values with\r\n\r\n\t\t@returns A function that will return true iff the condition is passed\r\n\t**--]]\r\n\tfunction t.array(check)\r\n\t\tassert(t.callback(check))\r\n\t\tlocal valuesCheck = t.values(check)\r\n\r\n\t\treturn function(value)\r\n\t\t\tlocal keySuccess, keyErrMsg = arrayKeysCheck(value)\r\n\t\t\tif keySuccess == false then\r\n\t\t\t\treturn false, string.format(\"[array] %s\", keyErrMsg or \"\")\r\n\t\t\tend\r\n\r\n\t\t\t-- # is unreliable for sparse arrays\r\n\t\t\t-- Count upwards using ipairs to avoid false positives from the behavior of #\r\n\t\t\tlocal arraySize = 0\r\n\r\n\t\t\tfor _ in ipairs(value) do\r\n\t\t\t\tarraySize = arraySize + 1\r\n\t\t\tend\r\n\r\n\t\t\tfor key in pairs(value) do\r\n\t\t\t\tif key < 1 or key > arraySize then\r\n\t\t\t\t\treturn false, string.format(\"[array] key %s must be sequential\", tostring(key))\r\n\t\t\t\tend\r\n\t\t\tend\r\n\r\n\t\t\tlocal valueSuccess, valueErrMsg = valuesCheck(value)\r\n\t\t\tif not valueSuccess then\r\n\t\t\t\treturn false, string.format(\"[array] %s\", valueErrMsg or \"\")\r\n\t\t\tend\r\n\r\n\t\t\treturn true\r\n\t\tend\r\n\tend\r\n\r\n--[[**\r\n\t\tensures value is an array of a strict makeup and size\r\n\r\n\t\t@param check The check to compare all values with\r\n\r\n\t\t@returns A function that will return true iff the condition is passed\r\n\t**--]]\r\n\tfunction t.strictArray(...)\r\n\t\tlocal valueTypes = { ... }\r\n\t\tassert(t.array(t.callback)(valueTypes))\r\n\r\n\t\treturn function(value)\r\n\t\t\tlocal keySuccess, keyErrMsg = arrayKeysCheck(value)\r\n\t\t\tif keySuccess == false then\r\n\t\t\t\treturn false, string.format(\"[strictArray] %s\", keyErrMsg or \"\")\r\n\t\t\tend\r\n\r\n\t\t\t-- If there's more than the set array size, disallow\r\n\t\t\tif #valueTypes < #value then\r\n\t\t\t\treturn false, string.format(\"[strictArray] Array size exceeds limit of %d\", #valueTypes)\r\n\t\t\tend\r\n\r\n\t\t\tfor idx, typeFn in pairs(valueTypes) do\r\n\t\t\t\tlocal typeSuccess, typeErrMsg = typeFn(value[idx])\r\n\t\t\t\tif not typeSuccess then\r\n\t\t\t\t\treturn false, string.format(\"[strictArray] Array index #%d - %s\", idx, typeErrMsg)\r\n\t\t\t\tend\r\n\t\t\tend\r\n\r\n\t\t\treturn true\r\n\t\tend\r\n\tend\r\nend\r\n\r\ndo\r\n\tlocal callbackArray = t.array(t.callback)\r\n--[[**\r\n\t\tcreates a union type\r\n\r\n\t\t@param ... The checks to union\r\n\r\n\t\t@returns A function that will return true iff the condition is passed\r\n\t**--]]\r\n\tfunction t.union(...)\r\n\t\tlocal checks = { ... }\r\n\t\tassert(callbackArray(checks))\r\n\r\n\t\treturn function(value)\r\n\t\t\tfor _, check in ipairs(checks) do\r\n\t\t\t\tif check(value) then\r\n\t\t\t\t\treturn true\r\n\t\t\t\tend\r\n\t\t\tend\r\n\r\n\t\t\treturn false, \"bad type for union\"\r\n\t\tend\r\n\tend\r\n\r\n--[[**\r\n\t\tAlias for t.union\r\n\t**--]]\r\n\tt.some = t.union\r\n\r\n--[[**\r\n\t\tcreates an intersection type\r\n\r\n\t\t@param ... The checks to intersect\r\n\r\n\t\t@returns A function that will return true iff the condition is passed\r\n\t**--]]\r\n\tfunction t.intersection(...)\r\n\t\tlocal checks = { ... }\r\n\t\tassert(callbackArray(checks))\r\n\r\n\t\treturn function(value)\r\n\t\t\tfor _, check in ipairs(checks) do\r\n\t\t\t\tlocal success, errMsg = check(value)\r\n\t\t\t\tif not success then\r\n\t\t\t\t\treturn false, errMsg or \"\"\r\n\t\t\t\tend\r\n\t\t\tend\r\n\r\n\t\t\treturn true\r\n\t\tend\r\n\tend\r\n\r\n--[[**\r\n\t\tAlias for t.intersection\r\n\t**--]]\r\n\tt.every = t.intersection\r\nend\r\n\r\ndo\r\n\tlocal checkInterface = t.map(t.any, t.callback)\r\n--[[**\r\n\t\tensures value matches given interface definition\r\n\r\n\t\t@param checkTable The interface definition\r\n\r\n\t\t@returns A function that will return true iff the condition is passed\r\n\t**--]]\r\n\tfunction t.interface(checkTable)\r\n\t\tassert(checkInterface(checkTable))\r\n\t\treturn function(value)\r\n\t\t\tlocal tableSuccess, tableErrMsg = t.table(value)\r\n\t\t\tif tableSuccess == false then\r\n\t\t\t\treturn false, tableErrMsg or \"\"\r\n\t\t\tend\r\n\r\n\t\t\tfor key, check in pairs(checkTable) do\r\n\t\t\t\tlocal success, errMsg = check(value[key])\r\n\t\t\t\tif success == false then\r\n\t\t\t\t\treturn false, string.format(\"[interface] bad value for %s:\\n\\t%s\", tostring(key), errMsg or \"\")\r\n\t\t\t\tend\r\n\t\t\tend\r\n\r\n\t\t\treturn true\r\n\t\tend\r\n\tend\r\n\r\n--[[**\r\n\t\tensures value matches given interface definition strictly\r\n\r\n\t\t@param checkTable The interface definition\r\n\r\n\t\t@returns A function that will return true iff the condition is passed\r\n\t**--]]\r\n\tfunction t.strictInterface(checkTable)\r\n\t\tassert(checkInterface(checkTable))\r\n\t\treturn function(value)\r\n\t\t\tlocal tableSuccess, tableErrMsg = t.table(value)\r\n\t\t\tif tableSuccess == false then\r\n\t\t\t\treturn false, tableErrMsg or \"\"\r\n\t\t\tend\r\n\r\n\t\t\tfor key, check in pairs(checkTable) do\r\n\t\t\t\tlocal success, errMsg = check(value[key])\r\n\t\t\t\tif success == false then\r\n\t\t\t\t\treturn false, string.format(\"[interface] bad value for %s:\\n\\t%s\", tostring(key), errMsg or \"\")\r\n\t\t\t\tend\r\n\t\t\tend\r\n\r\n\t\t\tfor key in pairs(value) do\r\n\t\t\t\tif not checkTable[key] then\r\n\t\t\t\t\treturn false, string.format(\"[interface] unexpected field %q\", tostring(key))\r\n\t\t\t\tend\r\n\t\t\tend\r\n\r\n\t\t\treturn true\r\n\t\tend\r\n\tend\r\nend\r\n\r\n--[[**\r\n\tensure value is an Instance and it's ClassName matches the given ClassName\r\n\r\n\t@param className The class name to check for\r\n\r\n\t@returns A function that will return true iff the condition is passed\r\n**--]]\r\nfunction t.instanceOf(className, childTable)\r\n\tassert(t.string(className))\r\n\r\n\tlocal childrenCheck\r\n\tif childTable ~= nil then\r\n\t\tchildrenCheck = t.children(childTable)\r\n\tend\r\n\r\n\treturn function(value)\r\n\t\tlocal instanceSuccess, instanceErrMsg = t.Instance(value)\r\n\t\tif not instanceSuccess then\r\n\t\t\treturn false, instanceErrMsg or \"\"\r\n\t\tend\r\n\r\n\t\tif value.ClassName ~= className then\r\n\t\t\treturn false, string.format(\"%s expected, got %s\", className, value.ClassName)\r\n\t\tend\r\n\r\n\t\tif childrenCheck then\r\n\t\t\tlocal childrenSuccess, childrenErrMsg = childrenCheck(value)\r\n\t\t\tif not childrenSuccess then\r\n\t\t\t\treturn false, childrenErrMsg\r\n\t\t\tend\r\n\t\tend\r\n\r\n\t\treturn true\r\n\tend\r\nend\r\n\r\nt.instance = t.instanceOf\r\n\r\n--[[**\r\n\tensure value is an Instance and it's ClassName matches the given ClassName by an IsA comparison\r\n\r\n\t@param className The class name to check for\r\n\r\n\t@returns A function that will return true iff the condition is passed\r\n**--]]\r\nfunction t.instanceIsA(className, childTable)\r\n\tassert(t.string(className))\r\n\r\n\tlocal childrenCheck\r\n\tif childTable ~= nil then\r\n\t\tchildrenCheck = t.children(childTable)\r\n\tend\r\n\r\n\treturn function(value)\r\n\t\tlocal instanceSuccess, instanceErrMsg = t.Instance(value)\r\n\t\tif not instanceSuccess then\r\n\t\t\treturn false, instanceErrMsg or \"\"\r\n\t\tend\r\n\r\n\t\tif not value:IsA(className) then\r\n\t\t\treturn false, string.format(\"%s expected, got %s\", className, value.ClassName)\r\n\t\tend\r\n\r\n\t\tif childrenCheck then\r\n\t\t\tlocal childrenSuccess, childrenErrMsg = childrenCheck(value)\r\n\t\t\tif not childrenSuccess then\r\n\t\t\t\treturn false, childrenErrMsg\r\n\t\t\tend\r\n\t\tend\r\n\r\n\t\treturn true\r\n\tend\r\nend\r\n\r\n--[[**\r\n\tensures value is an enum of the correct type\r\n\r\n\t@param enum The enum to check\r\n\r\n\t@returns A function that will return true iff the condition is passed\r\n**--]]\r\nfunction t.enum(enum)\r\n\tassert(t.Enum(enum))\r\n\treturn function(value)\r\n\t\tlocal enumItemSuccess, enumItemErrMsg = t.EnumItem(value)\r\n\t\tif not enumItemSuccess then\r\n\t\t\treturn false, enumItemErrMsg\r\n\t\tend\r\n\r\n\t\tif value.EnumType == enum then\r\n\t\t\treturn true\r\n\t\telse\r\n\t\t\treturn false, string.format(\"enum of %s expected, got enum of %s\", tostring(enum), tostring(value.EnumType))\r\n\t\tend\r\n\tend\r\nend\r\n\r\ndo\r\n\tlocal checkWrap = t.tuple(t.callback, t.callback)\r\n\r\n--[[**\r\n\t\twraps a callback in an assert with checkArgs\r\n\r\n\t\t@param callback The function to wrap\r\n\t\t@param checkArgs The function to use to check arguments in the assert\r\n\r\n\t\t@returns A function that first asserts using checkArgs and then calls callback\r\n\t**--]]\r\n\tfunction t.wrap(callback, checkArgs)\r\n\t\tassert(checkWrap(callback, checkArgs))\r\n\t\treturn function(...)\r\n\t\t\tassert(checkArgs(...))\r\n\t\t\treturn callback(...)\r\n\t\tend\r\n\tend\r\nend\r\n\r\n--[[**\r\n\tasserts a given check\r\n\r\n\t@param check The function to wrap with an assert\r\n\r\n\t@returns A function that simply wraps the given check in an assert\r\n**--]]\r\nfunction t.strict(check)\r\n\treturn function(...)\r\n\t\tassert(check(...))\r\n\tend\r\nend\r\n\r\ndo\r\n\tlocal checkChildren = t.map(t.string, t.callback)\r\n\r\n--[[**\r\n\t\tTakes a table where keys are child names and values are functions to check the children against.\r\n\t\tPass an instance tree into the function.\r\n\t\tIf at least one child passes each check, the overall check passes.\r\n\r\n\t\tWarning! If you pass in a tree with more than one child of the same name, this function will always return false\r\n\r\n\t\t@param checkTable The table to check against\r\n\r\n\t\t@returns A function that checks an instance tree\r\n\t**--]]\r\n\tfunction t.children(checkTable)\r\n\t\tassert(checkChildren(checkTable))\r\n\r\n\t\treturn function(value)\r\n\t\t\tlocal instanceSuccess, instanceErrMsg = t.Instance(value)\r\n\t\t\tif not instanceSuccess then\r\n\t\t\t\treturn false, instanceErrMsg or \"\"\r\n\t\t\tend\r\n\r\n\t\t\tlocal childrenByName = {}\r\n\t\t\tfor _, child in ipairs(value:GetChildren()) do\r\n\t\t\t\tlocal name = child.Name\r\n\t\t\t\tif checkTable[name] then\r\n\t\t\t\t\tif childrenByName[name] then\r\n\t\t\t\t\t\treturn false, string.format(\"Cannot process multiple children with the same name %q\", name)\r\n\t\t\t\t\tend\r\n\r\n\t\t\t\t\tchildrenByName[name] = child\r\n\t\t\t\tend\r\n\t\t\tend\r\n\r\n\t\t\tfor name, check in pairs(checkTable) do\r\n\t\t\t\tlocal success, errMsg = check(childrenByName[name])\r\n\t\t\t\tif not success then\r\n\t\t\t\t\treturn false, string.format(\"[%s.%s] %s\", value:GetFullName(), name, errMsg or \"\")\r\n\t\t\t\tend\r\n\t\t\tend\r\n\r\n\t\t\treturn true\r\n\t\tend\r\n\tend\r\nend\r\n\r\nreturn t\r\n"}},"Children":["d22adc3a9bd7195dae4e3c4ea2612c09","99ea57650081417fd256b7092ccdba19"],"Metadata":{"ignoreUnknownInstances":false}},"9ee814837a27b11857e89563135cd306":{"Id":"9ee814837a27b11857e89563135cd306","Parent":"2e2d4268ad91d40d489844d149b7c87e","Name":"shanebutt_t@1.3.1","ClassName":"Folder","Properties":{},"Children":["c39e26776de082e6222fc839fa8b1b48"],"Metadata":{"ignoreUnknownInstances":false}},"e412d57eace8911b86fabef6e8521d77":{"Id":"e412d57eace8911b86fabef6e8521d77","Parent":"ee222f38fa8be78c47f18fd875ac7854","Name":"Portal","ClassName":"ModuleScript","Properties":{"Source":{"String":"local HttpService: HttpService = game:GetService(\"HttpService\")\nlocal ReplicatedStorage: ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal RunService: RunService = game:GetService(\"RunService\")\n\nlocal t = require(script.Parent.t)\nlocal types = require(script.Types)\n\nlocal RemoteLocation = \"Portal\"\nlocal Storage: Folder = ReplicatedStorage:FindFirstChild(RemoteLocation) :: Folder\n\nif not Storage then\n\tif RunService:IsServer() then\n\t\tStorage = Instance.new(\"Folder\")\n\t\tStorage.Name = RemoteLocation\n\t\tStorage.Parent = ReplicatedStorage\n\telse\n\t\tStorage = ReplicatedStorage:WaitForChild(RemoteLocation)\n\tend\nend\n\ntype IContext = types.IContext\ntype ISubscription = types.ISubscription\ntype IWormhole = types.IWormhole\n\nlocal Context = require(script.Context)\nlocal Subscription = require(script.Subscription)\nlocal Wormhole = require(script.Wormhole)\n\nlocal Portal = {}\nPortal.Wormhole = Wormhole.new()\n\nfunction Portal:Context(context: string): IContext\n\treturn Portal.Wormhole.addContext(Portal.Wormhole, context)\nend\n\nfunction Portal:Subscription(context: string, action: string, cb: () -> ()?): ISubscription\n\treturn Portal.Wormhole.makeSubscription(Portal.Wormhole, context, action, cb)\nend\n\nfunction Portal:Subscribe(context: string, action: string, cb: () -> ())\n\tlocal subscription: ISubscription = Portal:Subscription(context, action, cb)\n\treturn Portal.Wormhole.doSubscribe(Portal.Wormhole, subscription)\nend\n\nfunction Portal:Publish(context: string, action: string, data: any) end\n\nreturn Portal\n"}},"Children":["2d5696ee5bdf4c8a0a542bf58f63b738","aa5772ae3a91cb8b93b724d7c5a15190","b006666de7a034699290c8f7a42446bf","d539d2b3547c9166dae5ffd367a37cb3","89734f1df997de85fd2bdd427ddf34fb"],"Metadata":{"ignoreUnknownInstances":false}}}}]======]
